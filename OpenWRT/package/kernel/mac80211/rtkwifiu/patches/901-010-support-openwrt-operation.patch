Index: backports-2017-11-01/drivers/net/wireless/realtek/rtkwifiu/rtl8723du/include/autoconf.h
===================================================================
--- backports-2017-11-01.orig/drivers/net/wireless/realtek/rtkwifiu/rtl8723du/include/autoconf.h
+++ backports-2017-11-01/drivers/net/wireless/realtek/rtkwifiu/rtl8723du/include/autoconf.h
@@ -63,7 +63,7 @@
 	#ifndef CONFIG_NATIVEAP_MLME
 		#define CONFIG_HOSTAPD_MLME
 	#endif
-	/* #define CONFIG_FIND_BEST_CHANNEL */
+	#define CONFIG_FIND_BEST_CHANNEL
 	/* #define CONFIG_NO_WIRELESS_HANDLERS */
 	#define CONFIG_TX_MCAST2UNI /* Support IP multicast to unicast */
 
Index: backports-2017-11-01/drivers/net/wireless/realtek/rtkwifiu/rtl8811au/os_dep/linux/ioctl_cfg80211.c
===================================================================
--- backports-2017-11-01.orig/drivers/net/wireless/realtek/rtkwifiu/rtl8811au/os_dep/linux/ioctl_cfg80211.c
+++ backports-2017-11-01/drivers/net/wireless/realtek/rtkwifiu/rtl8811au/os_dep/linux/ioctl_cfg80211.c
@@ -3979,7 +3979,7 @@ static int cfg80211_rtw_get_txpower(stru
 #endif
 	int *dbm)
 {
-	RTW_INFO("%s\n", __func__);
+	RTW_DBG("%s\n", __func__);
 
 	*dbm = (12);
 
@@ -5469,7 +5469,7 @@ static int	cfg80211_rtw_dump_station(str
 	u8 asoc_list_num;
 
 	if (DBG_DUMP_STATION)
-		RTW_INFO(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
+		RTW_DBG(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
 
 	_enter_critical_bh(&pstapriv->asoc_list_lock, &irqL);
 	psta = rtw_sta_info_get_by_idx(pstapriv, idx, &asoc_list_num);
@@ -5490,7 +5490,7 @@ static int	cfg80211_rtw_dump_station(str
 		#endif
 	) {
 		if (DBG_DUMP_STATION)
-			RTW_INFO(FUNC_NDEV_FMT" end with idx:%d\n", FUNC_NDEV_ARG(ndev), idx);
+			RTW_DBG(FUNC_NDEV_FMT" end with idx:%d\n", FUNC_NDEV_ARG(ndev), idx);
 		ret = -ENOENT;
 		goto exit;
 	}
@@ -9127,6 +9127,7 @@ static void rtw_cfg80211_preinit_wiphy(_
 		;
 #endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 3, 0)) */
 #endif /* CONFIG_RTW_MESH */
+	_rtw_memcpy(wiphy->perm_addr, adapter_mac_addr(adapter), ETH_ALEN);
 }
 
 #ifdef CONFIG_RFKILL_POLL
@@ -9300,6 +9301,63 @@ int rtw_hostapd_acs_dump_survey(struct w
 }
 #endif /* defined(CONFIG_RTW_HOSTAPD_ACS) && (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 33)) */
 
+static int cfg80211_rtw_get_channel(struct wiphy *wiphy, struct wireless_dev *wdev, struct cfg80211_chan_def *chandef)
+{
+	_adapter *padapter = wiphy_to_adapter(wiphy);
+	struct dvobj_priv *dvobj = adapter_to_dvobj(padapter);
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
+	struct ieee80211_channel *chan;
+	enum nl80211_band band;
+	int ret = -ENODATA;
+	int freq;
+	u8 center_ch;
+
+	if (pmlmeext->cur_channel > 14)
+		band = NL80211_BAND_5GHZ;
+	else
+		band = NL80211_BAND_2GHZ;
+
+	freq = ieee80211_channel_to_frequency(pmlmeext->cur_channel, band);
+	chan = ieee80211_get_channel(wiphy, freq);
+
+	switch (pmlmeext->cur_bwmode) {
+	case CHANNEL_WIDTH_20:
+		chandef->width = NL80211_CHAN_WIDTH_20;
+		break;
+	case CHANNEL_WIDTH_40:
+		chandef->width = NL80211_CHAN_WIDTH_40;
+		break;
+	case CHANNEL_WIDTH_80:
+		chandef->width = NL80211_CHAN_WIDTH_80;
+		break;
+	case CHANNEL_WIDTH_80_80:
+		chandef->width = NL80211_CHAN_WIDTH_80P80;
+		break;
+	case CHANNEL_WIDTH_160:
+		chandef->width = NL80211_CHAN_WIDTH_160;
+		break;
+	default:
+		WARN_ON(1);
+		break;
+	}
+
+	center_ch = rtw_get_center_ch(pmlmeext->cur_channel, pmlmeext->cur_bwmode, pmlmeext->cur_ch_offset);
+	chandef->chan = chan;
+	chandef->center_freq1 = ieee80211_channel_to_frequency(center_ch, band);
+	chandef->center_freq2 = 0;
+
+	if (cfg80211_chandef_valid(chandef))
+		ret = 0;
+
+	#ifdef CONFIG_DEBUG_CFG80211
+	printk("%s: ret=%d, cur_channel=%d, cur_bwmode=%d, cur_ch_offset=%d, band=%d, center_ch=%d\n",
+		__func__, ret, pmlmeext->cur_channel, pmlmeext->cur_bwmode, pmlmeext->cur_ch_offset, band, center_ch);
+	#endif
+
+	return ret;
+}
+
 static struct cfg80211_ops rtw_cfg80211_ops = {
 	.change_virtual_intf = cfg80211_rtw_change_iface,
 	.add_key = cfg80211_rtw_add_key,
@@ -9415,6 +9473,7 @@ static struct cfg80211_ops rtw_cfg80211_
 #if defined(CONFIG_RTW_HOSTAPD_ACS) && (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 33))
 	.dump_survey = rtw_hostapd_acs_dump_survey,
 #endif
+	.get_channel = cfg80211_rtw_get_channel,
 };
 
 struct wiphy *rtw_wiphy_alloc(_adapter *padapter, struct device *dev)
Index: backports-2017-11-01/drivers/net/wireless/realtek/rtkwifiu/rtl8812ae/os_dep/linux/ioctl_cfg80211.c
===================================================================
--- backports-2017-11-01.orig/drivers/net/wireless/realtek/rtkwifiu/rtl8812ae/os_dep/linux/ioctl_cfg80211.c
+++ backports-2017-11-01/drivers/net/wireless/realtek/rtkwifiu/rtl8812ae/os_dep/linux/ioctl_cfg80211.c
@@ -3202,7 +3202,7 @@ static int cfg80211_rtw_get_txpower(stru
 #endif
 	int *dbm)
 {
-	RTW_INFO("%s\n", __func__);
+	RTW_DBG("%s\n", __func__);
 
 	*dbm = (12);
 
@@ -4223,13 +4223,13 @@ static int	cfg80211_rtw_dump_station(str
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(ndev);
 	struct sta_info *psta = NULL;
 	struct sta_priv *pstapriv = &padapter->stapriv;
-	RTW_INFO(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
+	RTW_DBG(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
 
 	_enter_critical_bh(&pstapriv->asoc_list_lock, &irqL);
 	psta = rtw_sta_info_get_by_idx(idx, pstapriv);
 	_exit_critical_bh(&pstapriv->asoc_list_lock, &irqL);
 	if (NULL == psta) {
-		RTW_INFO("Station is not found\n");
+		RTW_DBG("Station is not found\n");
 		ret = -ENOENT;
 		goto exit;
 	}
@@ -5614,6 +5614,174 @@ static int cfg80211_rtw_sched_scan_stop(
 }
 #endif /* CONFIG_PNO_SUPPORT */
 
+#ifdef CONFIG_FIND_BEST_CHANNEL
+static int get_best_channel(_adapter *padapter, enum nl80211_band band)
+{
+	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
+	u32 i, best_channel_24G = 1, best_channel_5G = 36, index_24G = 0, index_5G = 0;
+
+	for (i=0; pmlmeext->channel_set[i].ChannelNum !=0; i++) {
+		if ( pmlmeext->channel_set[i].ChannelNum == 1)
+			index_24G = i;
+		if ( pmlmeext->channel_set[i].ChannelNum == 36)
+			index_5G = i;
+	}
+
+	for (i=0; (i < MAX_CHANNEL_NUM) && (pmlmeext->channel_set[i].ChannelNum !=0) ; i++) {
+		if (pmlmeext->channel_set[i].ScanType == SCAN_PASSIVE)
+			continue;
+		// 2.4G
+		if ( pmlmeext->channel_set[i].ChannelNum == 6 || pmlmeext->channel_set[i].ChannelNum == 11) {
+			if ( pmlmeext->channel_set[i].rx_count < pmlmeext->channel_set[index_24G].rx_count ) {
+				index_24G = i;
+				best_channel_24G = pmlmeext->channel_set[i].ChannelNum;
+			}
+		}
+
+		// 5G
+		if ( pmlmeext->channel_set[i].ChannelNum >= 36
+			&& pmlmeext->channel_set[i].ChannelNum < 140 ) {
+			// Find primary channel
+			if ( (( pmlmeext->channel_set[i].ChannelNum - 36) % 8 == 0)
+				&& (pmlmeext->channel_set[i].rx_count < pmlmeext->channel_set[index_5G].rx_count) ) {
+				index_5G = i;
+				best_channel_5G = pmlmeext->channel_set[i].ChannelNum;
+			}
+		}
+
+		if ( pmlmeext->channel_set[i].ChannelNum >= 149
+			&& pmlmeext->channel_set[i].ChannelNum < 165) {
+			// find primary channel
+			if ( (( pmlmeext->channel_set[i].ChannelNum - 149) % 8 == 0)
+				&& (pmlmeext->channel_set[i].rx_count < pmlmeext->channel_set[index_5G].rx_count) ) {
+				index_5G = i;
+				best_channel_5G = pmlmeext->channel_set[i].ChannelNum;
+			}
+		}
+	}
+
+	if (band == NL80211_BAND_2GHZ)
+		return best_channel_24G;
+
+	return best_channel_5G;
+}
+#endif
+
+static int cfg80211_rtw_dump_survey(struct wiphy *wiphy, struct net_device *dev, int idx, struct survey_info *survey)
+{
+	_adapter *padapter = wiphy_to_adapter(wiphy);
+	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
+	struct ss_res *ss = &pmlmeext->sitesurvey_res;
+	struct rtw_ieee80211_channel *ch;
+	struct ieee80211_supported_band *sband=NULL;
+	int freq, band=0;
+	int best_ch = -1;
+
+	if (idx >= ss->ch_num)
+		return -EINVAL;
+
+	ch = &ss->ch[idx];
+
+	if (!ch)
+		return -EINVAL;
+
+	if (ch->hw_value > 14)
+		band = NL80211_BAND_5GHZ;
+	else
+		band = NL80211_BAND_2GHZ;
+
+	sband = wiphy->bands[band];
+
+	if(!sband) {
+		printk("%s under unknown band!!\n",dev->name);
+		return -EINVAL;
+	}
+
+	if(sband->band == NL80211_BAND_2GHZ)
+		freq = ieee80211_channel_to_frequency(ch->hw_value, NL80211_BAND_2GHZ);
+	else
+		freq = ieee80211_channel_to_frequency(ch->hw_value, NL80211_BAND_5GHZ);
+
+	survey->channel = ieee80211_get_channel(wiphy, freq);
+	#ifdef CONFIG_FIND_BEST_CHANNEL
+	best_ch = get_best_channel(padapter, sband->band);
+	#endif
+
+	if (best_ch == ch->hw_value)
+		survey->noise = -100;
+	else
+		survey->noise = -50;
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4,0,0))
+	survey->time = 100;
+	survey->time_busy = 50;
+	survey->filled = SURVEY_INFO_NOISE_DBM | SURVEY_INFO_TIME | SURVEY_INFO_TIME_BUSY;
+#else
+	survey->channel_time = 100;
+	survey->channel_time_busy = 50
+	survey->filled = SURVEY_INFO_NOISE_DBM | SURVEY_INFO_CHANNEL_TIME | SURVEY_INFO_CHANNEL_TIME_BUSY;
+#endif
+
+	return 0;
+}
+
+static int cfg80211_rtw_get_channel(struct wiphy *wiphy, struct wireless_dev *wdev, struct cfg80211_chan_def *chandef)
+{
+	_adapter *padapter = wiphy_to_adapter(wiphy);
+	struct dvobj_priv *dvobj = adapter_to_dvobj(padapter);
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
+	struct ieee80211_channel *chan;
+	enum nl80211_band band;
+	int ret = -ENODATA;
+	int freq;
+	u8 center_ch;
+
+	if (pmlmeext->cur_channel > 14)
+		band = NL80211_BAND_5GHZ;
+	else
+		band = NL80211_BAND_2GHZ;
+
+	freq = ieee80211_channel_to_frequency(pmlmeext->cur_channel, band);
+	chan = ieee80211_get_channel(wiphy, freq);
+
+	switch (pmlmeext->cur_bwmode) {
+	case CHANNEL_WIDTH_20:
+		chandef->width = NL80211_CHAN_WIDTH_20;
+		break;
+	case CHANNEL_WIDTH_40:
+		chandef->width = NL80211_CHAN_WIDTH_40;
+		break;
+	case CHANNEL_WIDTH_80:
+		chandef->width = NL80211_CHAN_WIDTH_80;
+		break;
+	case CHANNEL_WIDTH_80_80:
+		chandef->width = NL80211_CHAN_WIDTH_80P80;
+		break;
+	case CHANNEL_WIDTH_160:
+		chandef->width = NL80211_CHAN_WIDTH_160;
+		break;
+	default:
+		WARN_ON(1);
+		break;
+	}
+
+	center_ch = rtw_get_center_ch(pmlmeext->cur_channel, pmlmeext->cur_bwmode, pmlmeext->cur_ch_offset);
+	chandef->chan = chan;
+	chandef->center_freq1 = ieee80211_channel_to_frequency(center_ch, band);
+	chandef->center_freq2 = 0;
+
+	if (cfg80211_chandef_valid(chandef))
+		ret = 0;
+
+	#ifdef CONFIG_DEBUG_CFG80211
+	printk("%s: ret=%d, cur_channel=%d, cur_bwmode=%d, cur_ch_offset=%d, band=%d, center_ch=%d\n",
+		__func__, ret, pmlmeext->cur_channel, pmlmeext->cur_bwmode, pmlmeext->cur_ch_offset, band, center_ch);
+	#endif
+
+	return ret;
+}
+
 static int rtw_cfg80211_set_beacon_wpsp2pie(struct net_device *ndev, char *buf, int len)
 {
 	int ret = 0;
@@ -6285,6 +6453,8 @@ static void rtw_cfg80211_preinit_wiphy(_
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 2, 0))
 	/* wiphy->flags |= WIPHY_FLAG_SUPPORTS_FW_ROAM; */
 #endif
+
+	_rtw_memcpy(wiphy->perm_addr, adapter_mac_addr(adapter), ETH_ALEN);
 }
 
 static struct cfg80211_ops rtw_cfg80211_ops = {
@@ -6366,6 +6536,8 @@ static struct cfg80211_ops rtw_cfg80211_
 	.sched_scan_start = cfg80211_rtw_sched_scan_start,
 	.sched_scan_stop = cfg80211_rtw_sched_scan_stop,
 #endif /* CONFIG_PNO_SUPPORT */
+	.dump_survey = cfg80211_rtw_dump_survey,
+	.get_channel = cfg80211_rtw_get_channel,
 };
 
 struct wiphy *rtw_wiphy_alloc(_adapter *padapter, struct device *dev)
Index: backports-2017-11-01/drivers/net/wireless/realtek/rtkwifiu/rtl8814au/os_dep/linux/ioctl_cfg80211.c
===================================================================
--- backports-2017-11-01.orig/drivers/net/wireless/realtek/rtkwifiu/rtl8814au/os_dep/linux/ioctl_cfg80211.c
+++ backports-2017-11-01/drivers/net/wireless/realtek/rtkwifiu/rtl8814au/os_dep/linux/ioctl_cfg80211.c
@@ -3527,7 +3527,7 @@ static int cfg80211_rtw_get_txpower(stru
 #endif
 	int *dbm)
 {
-	DBG_8192C("%s\n", __func__);
+	/* DBG_8192C("%s\n", __func__); */
 
 	*dbm = (12);
 	
@@ -4549,14 +4549,14 @@ static int	cfg80211_rtw_dump_station(str
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(ndev);
 	struct sta_info *psta = NULL;
 	struct sta_priv *pstapriv = &padapter->stapriv;
-	DBG_871X(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
+	/* DBG_871X(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev)); */
 
 	_enter_critical_bh(&pstapriv->asoc_list_lock, &irqL);
 	psta = rtw_sta_info_get_by_idx(idx, pstapriv);
 	_exit_critical_bh(&pstapriv->asoc_list_lock, &irqL);
 	if(NULL == psta)
 	{
-		DBG_871X("Station is not found\n");
+		/* DBG_871X("Station is not found\n"); */
 		ret = -ENOENT;
 		goto exit;
 	}
@@ -5885,6 +5885,174 @@ static int cfg80211_rtw_sched_scan_stop(
 }
 #endif /* CONFIG_PNO_SUPPORT */
 
+#ifdef CONFIG_FIND_BEST_CHANNEL
+static int get_best_channel(_adapter *padapter, enum nl80211_band band)
+{
+	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
+	u32 i, best_channel_24G = 1, best_channel_5G = 36, index_24G = 0, index_5G = 0;
+
+	for (i=0; pmlmeext->channel_set[i].ChannelNum !=0; i++) {
+		if ( pmlmeext->channel_set[i].ChannelNum == 1)
+			index_24G = i;
+		if ( pmlmeext->channel_set[i].ChannelNum == 36)
+			index_5G = i;
+	}
+
+	for (i=0; (i < MAX_CHANNEL_NUM) && (pmlmeext->channel_set[i].ChannelNum !=0) ; i++) {
+		if (pmlmeext->channel_set[i].ScanType == SCAN_PASSIVE)
+			continue;
+		// 2.4G
+		if ( pmlmeext->channel_set[i].ChannelNum == 6 || pmlmeext->channel_set[i].ChannelNum == 11) {
+			if ( pmlmeext->channel_set[i].rx_count < pmlmeext->channel_set[index_24G].rx_count ) {
+				index_24G = i;
+				best_channel_24G = pmlmeext->channel_set[i].ChannelNum;
+			}
+		}
+
+		// 5G
+		if ( pmlmeext->channel_set[i].ChannelNum >= 36
+			&& pmlmeext->channel_set[i].ChannelNum < 140 ) {
+			// Find primary channel
+			if ( (( pmlmeext->channel_set[i].ChannelNum - 36) % 8 == 0)
+				&& (pmlmeext->channel_set[i].rx_count < pmlmeext->channel_set[index_5G].rx_count) ) {
+				index_5G = i;
+				best_channel_5G = pmlmeext->channel_set[i].ChannelNum;
+			}
+		}
+
+		if ( pmlmeext->channel_set[i].ChannelNum >= 149
+			&& pmlmeext->channel_set[i].ChannelNum < 165) {
+			// find primary channel
+			if ( (( pmlmeext->channel_set[i].ChannelNum - 149) % 8 == 0)
+				&& (pmlmeext->channel_set[i].rx_count < pmlmeext->channel_set[index_5G].rx_count) ) {
+				index_5G = i;
+				best_channel_5G = pmlmeext->channel_set[i].ChannelNum;
+			}
+		}
+	}
+
+	if (band == NL80211_BAND_2GHZ)
+		return best_channel_24G;
+
+	return best_channel_5G;
+}
+#endif
+
+static int cfg80211_rtw_dump_survey(struct wiphy *wiphy, struct net_device *dev, int idx, struct survey_info *survey)
+{
+	_adapter *padapter = wiphy_to_adapter(wiphy);
+	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
+	struct ss_res *ss = &pmlmeext->sitesurvey_res;
+	struct rtw_ieee80211_channel *ch;
+	struct ieee80211_supported_band *sband=NULL;
+	int freq, band=0;
+	int best_ch = -1;
+
+	if (idx >= ss->ch_num)
+		return -EINVAL;
+
+	ch = &ss->ch[idx];
+
+	if (!ch)
+		return -EINVAL;
+
+	if (ch->hw_value > 14)
+		band = NL80211_BAND_5GHZ;
+	else
+		band = NL80211_BAND_2GHZ;
+
+	sband = wiphy->bands[band];
+
+	if(!sband) {
+		printk("%s under unknown band!!\n",dev->name);
+		return -EINVAL;
+	}
+
+	if(sband->band == NL80211_BAND_2GHZ)
+		freq = ieee80211_channel_to_frequency(ch->hw_value, NL80211_BAND_2GHZ);
+	else
+		freq = ieee80211_channel_to_frequency(ch->hw_value, NL80211_BAND_5GHZ);
+
+	survey->channel = ieee80211_get_channel(wiphy, freq);
+	#ifdef CONFIG_FIND_BEST_CHANNEL
+	best_ch = get_best_channel(padapter, sband->band);
+	#endif
+
+	if (best_ch == ch->hw_value)
+		survey->noise = -100;
+	else
+		survey->noise = -50;
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4,0,0))
+	survey->time = 100;
+	survey->time_busy = 50;
+	survey->filled = SURVEY_INFO_NOISE_DBM | SURVEY_INFO_TIME | SURVEY_INFO_TIME_BUSY;
+#else
+	survey->channel_time = 100;
+	survey->channel_time_busy = 50
+	survey->filled = SURVEY_INFO_NOISE_DBM | SURVEY_INFO_CHANNEL_TIME | SURVEY_INFO_CHANNEL_TIME_BUSY;
+#endif
+
+	return 0;
+}
+
+static int cfg80211_rtw_get_channel(struct wiphy *wiphy, struct wireless_dev *wdev, struct cfg80211_chan_def *chandef)
+{
+	_adapter *padapter = wiphy_to_adapter(wiphy);
+	struct dvobj_priv *dvobj = adapter_to_dvobj(padapter);
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
+	struct ieee80211_channel *chan;
+	enum nl80211_band band;
+	int ret = -ENODATA;
+	int freq;
+	u8 center_ch;
+
+	if (pmlmeext->cur_channel > 14)
+		band = NL80211_BAND_5GHZ;
+	else
+		band = NL80211_BAND_2GHZ;
+
+	freq = ieee80211_channel_to_frequency(pmlmeext->cur_channel, band);
+	chan = ieee80211_get_channel(wiphy, freq);
+
+	switch (pmlmeext->cur_bwmode) {
+	case CHANNEL_WIDTH_20:
+		chandef->width = NL80211_CHAN_WIDTH_20;
+		break;
+	case CHANNEL_WIDTH_40:
+		chandef->width = NL80211_CHAN_WIDTH_40;
+		break;
+	case CHANNEL_WIDTH_80:
+		chandef->width = NL80211_CHAN_WIDTH_80;
+		break;
+	case CHANNEL_WIDTH_80_80:
+		chandef->width = NL80211_CHAN_WIDTH_80P80;
+		break;
+	case CHANNEL_WIDTH_160:
+		chandef->width = NL80211_CHAN_WIDTH_160;
+		break;
+	default:
+		WARN_ON(1);
+		break;
+	}
+
+	center_ch = rtw_get_center_ch(pmlmeext->cur_channel, pmlmeext->cur_bwmode, pmlmeext->cur_ch_offset);
+	chandef->chan = chan;
+	chandef->center_freq1 = ieee80211_channel_to_frequency(center_ch, band);
+	chandef->center_freq2 = 0;
+
+	if (cfg80211_chandef_valid(chandef))
+		ret = 0;
+
+	#ifdef CONFIG_DEBUG_CFG80211
+	printk("%s: ret=%d, cur_channel=%d, cur_bwmode=%d, cur_ch_offset=%d, band=%d, center_ch=%d\n",
+		__func__, ret, pmlmeext->cur_channel, pmlmeext->cur_bwmode, pmlmeext->cur_ch_offset, band, center_ch);
+	#endif
+
+	return ret;
+}
+
 static int rtw_cfg80211_set_beacon_wpsp2pie(struct net_device *ndev, char *buf, int len)
 {	
 	int ret = 0;
@@ -6553,6 +6721,7 @@ static void rtw_cfg80211_preinit_wiphy(_
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,2,0))
 	//wiphy->flags |= WIPHY_FLAG_SUPPORTS_FW_ROAM;
 #endif
+	_rtw_memcpy(wiphy->perm_addr, adapter_mac_addr(adapter), ETH_ALEN);
 }
 
 static struct cfg80211_ops rtw_cfg80211_ops = {
@@ -6627,6 +6796,8 @@ static struct cfg80211_ops rtw_cfg80211_
 	.sched_scan_start = cfg80211_rtw_sched_scan_start,
 	.sched_scan_stop = cfg80211_rtw_sched_scan_stop,
 #endif /* CONFIG_PNO_SUPPORT */
+	.dump_survey = cfg80211_rtw_dump_survey,
+	.get_channel = cfg80211_rtw_get_channel,
 };
 
 struct wiphy *rtw_wiphy_alloc(_adapter *padapter, struct device *dev)
Index: backports-2017-11-01/drivers/net/wireless/realtek/rtkwifiu/rtl8188eu/os_dep/linux/ioctl_cfg80211.c
===================================================================
--- backports-2017-11-01.orig/drivers/net/wireless/realtek/rtkwifiu/rtl8188eu/os_dep/linux/ioctl_cfg80211.c
+++ backports-2017-11-01/drivers/net/wireless/realtek/rtkwifiu/rtl8188eu/os_dep/linux/ioctl_cfg80211.c
@@ -3392,7 +3392,7 @@ static int cfg80211_rtw_get_txpower(stru
 #endif
 	int *dbm)
 {
-	RTW_INFO("%s\n", __func__);
+	RTW_DBG("%s\n", __func__);
 
 	*dbm = (12);
 
@@ -4458,13 +4458,13 @@ static int	cfg80211_rtw_dump_station(str
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(ndev);
 	struct sta_info *psta = NULL;
 	struct sta_priv *pstapriv = &padapter->stapriv;
-	RTW_INFO(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
+	RTW_DBG(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
 
 	_enter_critical_bh(&pstapriv->asoc_list_lock, &irqL);
 	psta = rtw_sta_info_get_by_idx(idx, pstapriv);
 	_exit_critical_bh(&pstapriv->asoc_list_lock, &irqL);
 	if (NULL == psta) {
-		RTW_INFO("Station is not found\n");
+		RTW_DBG("Station is not found\n");
 		ret = -ENOENT;
 		goto exit;
 	}
@@ -6209,6 +6209,174 @@ static int cfg80211_rtw_sched_scan_stop(
 }
 #endif /* CONFIG_PNO_SUPPORT */
 
+#ifdef CONFIG_FIND_BEST_CHANNEL
+static int get_best_channel(_adapter *padapter, enum nl80211_band band)
+{
+	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
+	u32 i, best_channel_24G = 1, best_channel_5G = 36, index_24G = 0, index_5G = 0;
+
+	for (i=0; pmlmeext->channel_set[i].ChannelNum !=0; i++) {
+		if ( pmlmeext->channel_set[i].ChannelNum == 1)
+			index_24G = i;
+		if ( pmlmeext->channel_set[i].ChannelNum == 36)
+			index_5G = i;
+	}
+
+	for (i=0; (i < MAX_CHANNEL_NUM) && (pmlmeext->channel_set[i].ChannelNum !=0) ; i++) {
+		if (pmlmeext->channel_set[i].ScanType == SCAN_PASSIVE)
+			continue;
+		// 2.4G
+		if ( pmlmeext->channel_set[i].ChannelNum == 6 || pmlmeext->channel_set[i].ChannelNum == 11) {
+			if ( pmlmeext->channel_set[i].rx_count < pmlmeext->channel_set[index_24G].rx_count ) {
+				index_24G = i;
+				best_channel_24G = pmlmeext->channel_set[i].ChannelNum;
+			}
+		}
+
+		// 5G
+		if ( pmlmeext->channel_set[i].ChannelNum >= 36
+			&& pmlmeext->channel_set[i].ChannelNum < 140 ) {
+			// Find primary channel
+			if ( (( pmlmeext->channel_set[i].ChannelNum - 36) % 8 == 0)
+				&& (pmlmeext->channel_set[i].rx_count < pmlmeext->channel_set[index_5G].rx_count) ) {
+				index_5G = i;
+				best_channel_5G = pmlmeext->channel_set[i].ChannelNum;
+			}
+		}
+
+		if ( pmlmeext->channel_set[i].ChannelNum >= 149
+			&& pmlmeext->channel_set[i].ChannelNum < 165) {
+			// find primary channel
+			if ( (( pmlmeext->channel_set[i].ChannelNum - 149) % 8 == 0)
+				&& (pmlmeext->channel_set[i].rx_count < pmlmeext->channel_set[index_5G].rx_count) ) {
+				index_5G = i;
+				best_channel_5G = pmlmeext->channel_set[i].ChannelNum;
+			}
+		}
+	}
+
+	if (band == NL80211_BAND_2GHZ)
+		return best_channel_24G;
+
+	return best_channel_5G;
+}
+#endif
+
+static int cfg80211_rtw_dump_survey(struct wiphy *wiphy, struct net_device *dev, int idx, struct survey_info *survey)
+{
+	_adapter *padapter = wiphy_to_adapter(wiphy);
+	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
+	struct ss_res *ss = &pmlmeext->sitesurvey_res;
+	struct rtw_ieee80211_channel *ch;
+	struct ieee80211_supported_band *sband=NULL;
+	int freq, band=0;
+	int best_ch = -1;
+
+	if (idx >= ss->ch_num)
+		return -EINVAL;
+
+	ch = &ss->ch[idx];
+
+	if (!ch)
+		return -EINVAL;
+
+	if (ch->hw_value > 14)
+		band = NL80211_BAND_5GHZ;
+	else
+		band = NL80211_BAND_2GHZ;
+
+	sband = wiphy->bands[band];
+
+	if(!sband) {
+		printk("%s under unknown band!!\n",dev->name);
+		return -EINVAL;
+	}
+
+	if(sband->band == NL80211_BAND_2GHZ)
+		freq = ieee80211_channel_to_frequency(ch->hw_value, NL80211_BAND_2GHZ);
+	else
+		freq = ieee80211_channel_to_frequency(ch->hw_value, NL80211_BAND_5GHZ);
+
+	survey->channel = ieee80211_get_channel(wiphy, freq);
+	#ifdef CONFIG_FIND_BEST_CHANNEL
+	best_ch = get_best_channel(padapter, sband->band);
+	#endif
+
+	if (best_ch == ch->hw_value)
+		survey->noise = -100;
+	else
+		survey->noise = -50;
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4,0,0))
+	survey->time = 100;
+	survey->time_busy = 50;
+	survey->filled = SURVEY_INFO_NOISE_DBM | SURVEY_INFO_TIME | SURVEY_INFO_TIME_BUSY;
+#else
+	survey->channel_time = 100;
+	survey->channel_time_busy = 50
+	survey->filled = SURVEY_INFO_NOISE_DBM | SURVEY_INFO_CHANNEL_TIME | SURVEY_INFO_CHANNEL_TIME_BUSY;
+#endif
+
+	return 0;
+}
+
+static int cfg80211_rtw_get_channel(struct wiphy *wiphy, struct wireless_dev *wdev, struct cfg80211_chan_def *chandef)
+{
+	_adapter *padapter = wiphy_to_adapter(wiphy);
+	struct dvobj_priv *dvobj = adapter_to_dvobj(padapter);
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
+	struct ieee80211_channel *chan;
+	enum nl80211_band band;
+	int ret = -ENODATA;
+	int freq;
+	u8 center_ch;
+
+	if (pmlmeext->cur_channel > 14)
+		band = NL80211_BAND_5GHZ;
+	else
+		band = NL80211_BAND_2GHZ;
+
+	freq = ieee80211_channel_to_frequency(pmlmeext->cur_channel, band);
+	chan = ieee80211_get_channel(wiphy, freq);
+
+	switch (pmlmeext->cur_bwmode) {
+	case CHANNEL_WIDTH_20:
+		chandef->width = NL80211_CHAN_WIDTH_20;
+		break;
+	case CHANNEL_WIDTH_40:
+		chandef->width = NL80211_CHAN_WIDTH_40;
+		break;
+	case CHANNEL_WIDTH_80:
+		chandef->width = NL80211_CHAN_WIDTH_80;
+		break;
+	case CHANNEL_WIDTH_80_80:
+		chandef->width = NL80211_CHAN_WIDTH_80P80;
+		break;
+	case CHANNEL_WIDTH_160:
+		chandef->width = NL80211_CHAN_WIDTH_160;
+		break;
+	default:
+		WARN_ON(1);
+		break;
+	}
+
+	center_ch = rtw_get_center_ch(pmlmeext->cur_channel, pmlmeext->cur_bwmode, pmlmeext->cur_ch_offset);
+	chandef->chan = chan;
+	chandef->center_freq1 = ieee80211_channel_to_frequency(center_ch, band);
+	chandef->center_freq2 = 0;
+
+	if (cfg80211_chandef_valid(chandef))
+		ret = 0;
+
+	#ifdef CONFIG_DEBUG_CFG80211
+	printk("%s: ret=%d, cur_channel=%d, cur_bwmode=%d, cur_ch_offset=%d, band=%d, center_ch=%d\n",
+		__func__, ret, pmlmeext->cur_channel, pmlmeext->cur_bwmode, pmlmeext->cur_ch_offset, band, center_ch);
+	#endif
+
+	return ret;
+}
+
 static int rtw_cfg80211_set_beacon_wpsp2pie(struct net_device *ndev, char *buf, int len)
 {
 	int ret = 0;
@@ -6855,6 +7023,7 @@ static void rtw_cfg80211_preinit_wiphy(_
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 2, 0))
 	/* wiphy->flags |= WIPHY_FLAG_SUPPORTS_FW_ROAM; */
 #endif
+	_rtw_memcpy(wiphy->perm_addr, adapter_mac_addr(adapter), ETH_ALEN);
 }
 
 #ifdef CONFIG_RFKILL_POLL
@@ -6979,6 +7148,8 @@ static struct cfg80211_ops rtw_cfg80211_
 	.sched_scan_start = cfg80211_rtw_sched_scan_start,
 	.sched_scan_stop = cfg80211_rtw_sched_scan_stop,
 #endif /* CONFIG_PNO_SUPPORT */
+	.dump_survey = cfg80211_rtw_dump_survey,
+	.get_channel = cfg80211_rtw_get_channel,
 #ifdef CONFIG_RFKILL_POLL
 	.rfkill_poll = cfg80211_rtw_rfkill_poll,
 #endif
Index: backports-2017-11-01/drivers/net/wireless/realtek/rtkwifiu/rtl8188fu/os_dep/linux/ioctl_cfg80211.c
===================================================================
--- backports-2017-11-01.orig/drivers/net/wireless/realtek/rtkwifiu/rtl8188fu/os_dep/linux/ioctl_cfg80211.c
+++ backports-2017-11-01/drivers/net/wireless/realtek/rtkwifiu/rtl8188fu/os_dep/linux/ioctl_cfg80211.c
@@ -3934,7 +3934,7 @@ static int cfg80211_rtw_get_txpower(stru
 #endif
 	int *dbm)
 {
-	RTW_INFO("%s\n", __func__);
+	RTW_DBG("%s\n", __func__);
 
 	*dbm = (12);
 
@@ -5424,7 +5424,7 @@ static int	cfg80211_rtw_dump_station(str
 	u8 asoc_list_num;
 
 	if (DBG_DUMP_STATION)
-		RTW_INFO(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
+		RTW_DBG(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
 
 	_enter_critical_bh(&pstapriv->asoc_list_lock, &irqL);
 	psta = rtw_sta_info_get_by_idx(pstapriv, idx, &asoc_list_num);
@@ -5445,7 +5445,7 @@ static int	cfg80211_rtw_dump_station(str
 		#endif
 	) {
 		if (DBG_DUMP_STATION)
-			RTW_INFO(FUNC_NDEV_FMT" end with idx:%d\n", FUNC_NDEV_ARG(ndev), idx);
+			RTW_DBG(FUNC_NDEV_FMT" end with idx:%d\n", FUNC_NDEV_ARG(ndev), idx);
 		ret = -ENOENT;
 		goto exit;
 	}
@@ -9037,6 +9037,8 @@ static void rtw_cfg80211_preinit_wiphy(_
 	/* wiphy->flags |= WIPHY_FLAG_SUPPORTS_FW_ROAM; */
 #endif
 
+	_rtw_memcpy(wiphy->perm_addr, adapter_mac_addr(adapter), ETH_ALEN);
+
 #ifdef CONFIG_RTW_MESH
 	wiphy->flags |= 0
 		#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37))
@@ -9228,6 +9230,64 @@ int rtw_hostapd_acs_dump_survey(struct w
 }
 #endif /* defined(CONFIG_RTW_HOSTAPD_ACS) && (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 33)) */
 
+static int cfg80211_rtw_get_channel(struct wiphy *wiphy, struct wireless_dev *wdev, struct cfg80211_chan_def *chandef)
+{
+	_adapter *padapter = wiphy_to_adapter(wiphy);
+	struct dvobj_priv *dvobj = adapter_to_dvobj(padapter);
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
+	struct ieee80211_channel *chan;
+	enum nl80211_band band;
+	int ret = -ENODATA;
+	int freq;
+	u8 center_ch;
+
+	if (pmlmeext->cur_channel > 14)
+		band = NL80211_BAND_5GHZ;
+	else
+		band = NL80211_BAND_2GHZ;
+
+	freq = ieee80211_channel_to_frequency(pmlmeext->cur_channel, band);
+	chan = ieee80211_get_channel(wiphy, freq);
+
+	switch (pmlmeext->cur_bwmode) {
+	case CHANNEL_WIDTH_20:
+		chandef->width = NL80211_CHAN_WIDTH_20;
+		break;
+	case CHANNEL_WIDTH_40:
+		chandef->width = NL80211_CHAN_WIDTH_40;
+		break;
+	case CHANNEL_WIDTH_80:
+		chandef->width = NL80211_CHAN_WIDTH_80;
+		break;
+	case CHANNEL_WIDTH_80_80:
+		chandef->width = NL80211_CHAN_WIDTH_80P80;
+		break;
+	case CHANNEL_WIDTH_160:
+		chandef->width = NL80211_CHAN_WIDTH_160;
+		break;
+	default:
+		WARN_ON(1);
+		break;
+	}
+
+	center_ch = rtw_get_center_ch(pmlmeext->cur_channel, pmlmeext->cur_bwmode, pmlmeext->cur_ch_offset);
+	chandef->chan = chan;
+	chandef->center_freq1 = ieee80211_channel_to_frequency(center_ch, band);
+	chandef->center_freq2 = 0;
+
+	if (cfg80211_chandef_valid(chandef))
+		ret = 0;
+
+	#ifdef CONFIG_DEBUG_CFG80211
+	printk("%s: ret=%d, cur_channel=%d, cur_bwmode=%d, cur_ch_offset=%d, band=%d, center_ch=%d\n",
+		__func__, ret, pmlmeext->cur_channel, pmlmeext->cur_bwmode, pmlmeext->cur_ch_offset, band, center_ch);
+	#endif
+
+	return ret;
+}
+
+
 static struct cfg80211_ops rtw_cfg80211_ops = {
 	.change_virtual_intf = cfg80211_rtw_change_iface,
 	.add_key = cfg80211_rtw_add_key,
@@ -9343,6 +9403,7 @@ static struct cfg80211_ops rtw_cfg80211_
 #if defined(CONFIG_RTW_HOSTAPD_ACS) && (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 33))
 	.dump_survey = rtw_hostapd_acs_dump_survey,
 #endif
+	.get_channel = cfg80211_rtw_get_channel,
 };
 
 struct wiphy *rtw_wiphy_alloc(_adapter *padapter, struct device *dev)
Index: backports-2017-11-01/drivers/net/wireless/realtek/rtkwifiu/rtl8723du/os_dep/linux/ioctl_cfg80211.c
===================================================================
--- backports-2017-11-01.orig/drivers/net/wireless/realtek/rtkwifiu/rtl8723du/os_dep/linux/ioctl_cfg80211.c
+++ backports-2017-11-01/drivers/net/wireless/realtek/rtkwifiu/rtl8723du/os_dep/linux/ioctl_cfg80211.c
@@ -4089,7 +4089,7 @@ static int cfg80211_rtw_get_txpower(stru
 #endif
 	int *dbm)
 {
-	RTW_INFO("%s\n", __func__);
+	RTW_DBG("%s\n", __func__);
 
 	*dbm = (12);
 
@@ -5642,7 +5642,7 @@ static int	cfg80211_rtw_dump_station(str
 	u8 asoc_list_num;
 
 	if (DBG_DUMP_STATION)
-		RTW_INFO(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
+		RTW_DBG(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
 
 	_enter_critical_bh(&pstapriv->asoc_list_lock, &irqL);
 	psta = rtw_sta_info_get_by_idx(pstapriv, idx, &asoc_list_num);
@@ -5663,7 +5663,7 @@ static int	cfg80211_rtw_dump_station(str
 		#endif
 	) {
 		if (DBG_DUMP_STATION)
-			RTW_INFO(FUNC_NDEV_FMT" end with idx:%d\n", FUNC_NDEV_ARG(ndev), idx);
+			RTW_DBG(FUNC_NDEV_FMT" end with idx:%d\n", FUNC_NDEV_ARG(ndev), idx);
 		ret = -ENOENT;
 		goto exit;
 	}
@@ -9397,6 +9397,7 @@ static void rtw_cfg80211_preinit_wiphy(_
 		;
 #endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 3, 0)) */
 #endif /* CONFIG_RTW_MESH */
+	_rtw_memcpy(wiphy->perm_addr, adapter_mac_addr(adapter), ETH_ALEN);
 }
 
 #ifdef CONFIG_RFKILL_POLL
@@ -9570,6 +9571,63 @@ int rtw_hostapd_acs_dump_survey(struct w
 }
 #endif /* defined(CONFIG_RTW_HOSTAPD_ACS) && (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 33)) */
 
+static int cfg80211_rtw_get_channel(struct wiphy *wiphy, struct wireless_dev *wdev, struct cfg80211_chan_def *chandef)
+{
+	_adapter *padapter = wiphy_to_adapter(wiphy);
+	struct dvobj_priv *dvobj = adapter_to_dvobj(padapter);
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
+	struct ieee80211_channel *chan;
+	enum nl80211_band band;
+	int ret = -ENODATA;
+	int freq;
+	u8 center_ch;
+
+	if (pmlmeext->cur_channel > 14)
+		band = NL80211_BAND_5GHZ;
+	else
+		band = NL80211_BAND_2GHZ;
+
+	freq = ieee80211_channel_to_frequency(pmlmeext->cur_channel, band);
+	chan = ieee80211_get_channel(wiphy, freq);
+
+	switch (pmlmeext->cur_bwmode) {
+	case CHANNEL_WIDTH_20:
+		chandef->width = NL80211_CHAN_WIDTH_20;
+		break;
+	case CHANNEL_WIDTH_40:
+		chandef->width = NL80211_CHAN_WIDTH_40;
+		break;
+	case CHANNEL_WIDTH_80:
+		chandef->width = NL80211_CHAN_WIDTH_80;
+		break;
+	case CHANNEL_WIDTH_80_80:
+		chandef->width = NL80211_CHAN_WIDTH_80P80;
+		break;
+	case CHANNEL_WIDTH_160:
+		chandef->width = NL80211_CHAN_WIDTH_160;
+		break;
+	default:
+		WARN_ON(1);
+		break;
+	}
+
+	center_ch = rtw_get_center_ch(pmlmeext->cur_channel, pmlmeext->cur_bwmode, pmlmeext->cur_ch_offset);
+	chandef->chan = chan;
+	chandef->center_freq1 = ieee80211_channel_to_frequency(center_ch, band);
+	chandef->center_freq2 = 0;
+
+	if (cfg80211_chandef_valid(chandef))
+		ret = 0;
+
+	#ifdef CONFIG_DEBUG_CFG80211
+	printk("%s: ret=%d, cur_channel=%d, cur_bwmode=%d, cur_ch_offset=%d, band=%d, center_ch=%d\n",
+		__func__, ret, pmlmeext->cur_channel, pmlmeext->cur_bwmode, pmlmeext->cur_ch_offset, band, center_ch);
+	#endif
+
+	return ret;
+}
+
 static struct cfg80211_ops rtw_cfg80211_ops = {
 	.change_virtual_intf = cfg80211_rtw_change_iface,
 	.add_key = cfg80211_rtw_add_key,
@@ -9688,6 +9746,7 @@ static struct cfg80211_ops rtw_cfg80211_
 #if defined(CONFIG_RTW_HOSTAPD_ACS) && (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 33))
 	.dump_survey = rtw_hostapd_acs_dump_survey,
 #endif
+	.get_channel = cfg80211_rtw_get_channel,
 };
 
 struct wiphy *rtw_wiphy_alloc(_adapter *padapter, struct device *dev)
Index: backports-2017-11-01/drivers/net/wireless/realtek/rtkwifiu/rtl8812au/os_dep/linux/ioctl_cfg80211.c
===================================================================
--- backports-2017-11-01.orig/drivers/net/wireless/realtek/rtkwifiu/rtl8812au/os_dep/linux/ioctl_cfg80211.c
+++ backports-2017-11-01/drivers/net/wireless/realtek/rtkwifiu/rtl8812au/os_dep/linux/ioctl_cfg80211.c
@@ -3620,7 +3620,7 @@ static int cfg80211_rtw_get_txpower(stru
 #endif
 	int *dbm)
 {
-	RTW_INFO("%s\n", __func__);
+	RTW_DBG("%s\n", __func__);
 
 	*dbm = (12);
 
@@ -4687,13 +4687,13 @@ static int	cfg80211_rtw_dump_station(str
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(ndev);
 	struct sta_info *psta = NULL;
 	struct sta_priv *pstapriv = &padapter->stapriv;
-	RTW_INFO(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
+	RTW_DBG(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
 
 	_enter_critical_bh(&pstapriv->asoc_list_lock, &irqL);
 	psta = rtw_sta_info_get_by_idx(idx, pstapriv);
 	_exit_critical_bh(&pstapriv->asoc_list_lock, &irqL);
 	if (NULL == psta) {
-		RTW_INFO("Station is not found\n");
+		RTW_DBG("Station is not found\n");
 		ret = -ENOENT;
 		goto exit;
 	}
@@ -7144,6 +7144,7 @@ static void rtw_cfg80211_preinit_wiphy(_
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 2, 0))
 	/* wiphy->flags |= WIPHY_FLAG_SUPPORTS_FW_ROAM; */
 #endif
+	_rtw_memcpy(wiphy->perm_addr, adapter_mac_addr(adapter), ETH_ALEN);
 }
 
 #ifdef CONFIG_RFKILL_POLL
@@ -7317,6 +7318,63 @@ int rtw_hostapd_acs_dump_survey(struct w
 }
 #endif /* defined(CONFIG_RTW_HOSTAPD_ACS) && (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 33)) */
 
+static int cfg80211_rtw_get_channel(struct wiphy *wiphy, struct wireless_dev *wdev, struct cfg80211_chan_def *chandef)
+{
+	_adapter *padapter = wiphy_to_adapter(wiphy);
+	struct dvobj_priv *dvobj = adapter_to_dvobj(padapter);
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
+	struct ieee80211_channel *chan;
+	enum nl80211_band band;
+	int ret = -ENODATA;
+	int freq;
+	u8 center_ch;
+
+	if (pmlmeext->cur_channel > 14)
+		band = NL80211_BAND_5GHZ;
+	else
+		band = NL80211_BAND_2GHZ;
+
+	freq = ieee80211_channel_to_frequency(pmlmeext->cur_channel, band);
+	chan = ieee80211_get_channel(wiphy, freq);
+
+	switch (pmlmeext->cur_bwmode) {
+	case CHANNEL_WIDTH_20:
+		chandef->width = NL80211_CHAN_WIDTH_20;
+		break;
+	case CHANNEL_WIDTH_40:
+		chandef->width = NL80211_CHAN_WIDTH_40;
+		break;
+	case CHANNEL_WIDTH_80:
+		chandef->width = NL80211_CHAN_WIDTH_80;
+		break;
+	case CHANNEL_WIDTH_80_80:
+		chandef->width = NL80211_CHAN_WIDTH_80P80;
+		break;
+	case CHANNEL_WIDTH_160:
+		chandef->width = NL80211_CHAN_WIDTH_160;
+		break;
+	default:
+		WARN_ON(1);
+		break;
+	}
+
+	center_ch = rtw_get_center_ch(pmlmeext->cur_channel, pmlmeext->cur_bwmode, pmlmeext->cur_ch_offset);
+	chandef->chan = chan;
+	chandef->center_freq1 = ieee80211_channel_to_frequency(center_ch, band);
+	chandef->center_freq2 = 0;
+
+	if (cfg80211_chandef_valid(chandef))
+		ret = 0;
+
+	#ifdef CONFIG_DEBUG_CFG80211
+	printk("%s: ret=%d, cur_channel=%d, cur_bwmode=%d, cur_ch_offset=%d, band=%d, center_ch=%d\n",
+		__func__, ret, pmlmeext->cur_channel, pmlmeext->cur_bwmode, pmlmeext->cur_ch_offset, band, center_ch);
+	#endif
+
+	return ret;
+}
+
 static struct cfg80211_ops rtw_cfg80211_ops = {
 	.change_virtual_intf = cfg80211_rtw_change_iface,
 	.add_key = cfg80211_rtw_add_key,
@@ -7413,6 +7471,7 @@ static struct cfg80211_ops rtw_cfg80211_
 #if defined(CONFIG_RTW_HOSTAPD_ACS) && (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 33))
 	.dump_survey = rtw_hostapd_acs_dump_survey,
 #endif
+	.get_channel = cfg80211_rtw_get_channel,
 };
 
 struct wiphy *rtw_wiphy_alloc(_adapter *padapter, struct device *dev)
Index: backports-2017-11-01/drivers/net/wireless/realtek/rtkwifiu/rtl8821cs/os_dep/linux/ioctl_cfg80211.c
===================================================================
--- backports-2017-11-01.orig/drivers/net/wireless/realtek/rtkwifiu/rtl8821cs/os_dep/linux/ioctl_cfg80211.c
+++ backports-2017-11-01/drivers/net/wireless/realtek/rtkwifiu/rtl8821cs/os_dep/linux/ioctl_cfg80211.c
@@ -4060,7 +4060,7 @@ static int cfg80211_rtw_get_txpower(stru
 #endif
 	int *dbm)
 {
-	RTW_INFO("%s\n", __func__);
+	RTW_DBG("%s\n", __func__);
 
 	*dbm = (12);
 
@@ -5613,7 +5613,7 @@ static int	cfg80211_rtw_dump_station(str
 	u8 asoc_list_num;
 
 	if (DBG_DUMP_STATION)
-		RTW_INFO(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
+		RTW_DBG(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
 
 	_enter_critical_bh(&pstapriv->asoc_list_lock, &irqL);
 	psta = rtw_sta_info_get_by_idx(pstapriv, idx, &asoc_list_num);
@@ -5634,7 +5634,7 @@ static int	cfg80211_rtw_dump_station(str
 		#endif
 	) {
 		if (DBG_DUMP_STATION)
-			RTW_INFO(FUNC_NDEV_FMT" end with idx:%d\n", FUNC_NDEV_ARG(ndev), idx);
+			RTW_DBG(FUNC_NDEV_FMT" end with idx:%d\n", FUNC_NDEV_ARG(ndev), idx);
 		ret = -ENOENT;
 		goto exit;
 	}
@@ -9353,6 +9353,7 @@ static void rtw_cfg80211_preinit_wiphy(_
 		;
 #endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 3, 0)) */
 #endif /* CONFIG_RTW_MESH */
+	_rtw_memcpy(wiphy->perm_addr, adapter_mac_addr(adapter), ETH_ALEN);
 }
 
 #ifdef CONFIG_RFKILL_POLL
@@ -9526,6 +9527,63 @@ int rtw_hostapd_acs_dump_survey(struct w
 }
 #endif /* defined(CONFIG_RTW_HOSTAPD_ACS) && (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 33)) */
 
+static int cfg80211_rtw_get_channel(struct wiphy *wiphy, struct wireless_dev *wdev, struct cfg80211_chan_def *chandef)
+{
+	_adapter *padapter = wiphy_to_adapter(wiphy);
+	struct dvobj_priv *dvobj = adapter_to_dvobj(padapter);
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
+	struct ieee80211_channel *chan;
+	enum nl80211_band band;
+	int ret = -ENODATA;
+	int freq;
+	u8 center_ch;
+
+	if (pmlmeext->cur_channel > 14)
+		band = NL80211_BAND_5GHZ;
+	else
+		band = NL80211_BAND_2GHZ;
+
+	freq = ieee80211_channel_to_frequency(pmlmeext->cur_channel, band);
+	chan = ieee80211_get_channel(wiphy, freq);
+
+	switch (pmlmeext->cur_bwmode) {
+	case CHANNEL_WIDTH_20:
+		chandef->width = NL80211_CHAN_WIDTH_20;
+		break;
+	case CHANNEL_WIDTH_40:
+		chandef->width = NL80211_CHAN_WIDTH_40;
+		break;
+	case CHANNEL_WIDTH_80:
+		chandef->width = NL80211_CHAN_WIDTH_80;
+		break;
+	case CHANNEL_WIDTH_80_80:
+		chandef->width = NL80211_CHAN_WIDTH_80P80;
+		break;
+	case CHANNEL_WIDTH_160:
+		chandef->width = NL80211_CHAN_WIDTH_160;
+		break;
+	default:
+		WARN_ON(1);
+		break;
+	}
+
+	center_ch = rtw_get_center_ch(pmlmeext->cur_channel, pmlmeext->cur_bwmode, pmlmeext->cur_ch_offset);
+	chandef->chan = chan;
+	chandef->center_freq1 = ieee80211_channel_to_frequency(center_ch, band);
+	chandef->center_freq2 = 0;
+
+	if (cfg80211_chandef_valid(chandef))
+		ret = 0;
+
+	#ifdef CONFIG_DEBUG_CFG80211
+	printk("%s: ret=%d, cur_channel=%d, cur_bwmode=%d, cur_ch_offset=%d, band=%d, center_ch=%d\n",
+		__func__, ret, pmlmeext->cur_channel, pmlmeext->cur_bwmode, pmlmeext->cur_ch_offset, band, center_ch);
+	#endif
+
+	return ret;
+}
+
 static struct cfg80211_ops rtw_cfg80211_ops = {
 	.change_virtual_intf = cfg80211_rtw_change_iface,
 	.add_key = cfg80211_rtw_add_key,
@@ -9644,6 +9702,7 @@ static struct cfg80211_ops rtw_cfg80211_
 #if defined(CONFIG_RTW_HOSTAPD_ACS) && (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 33))
 	.dump_survey = rtw_hostapd_acs_dump_survey,
 #endif
+	.get_channel = cfg80211_rtw_get_channel,
 };
 
 struct wiphy *rtw_wiphy_alloc(_adapter *padapter, struct device *dev)
Index: backports-2017-11-01/drivers/net/wireless/realtek/rtkwifiu/rtl8723bs/os_dep/linux/ioctl_cfg80211.c
===================================================================
--- backports-2017-11-01.orig/drivers/net/wireless/realtek/rtkwifiu/rtl8723bs/os_dep/linux/ioctl_cfg80211.c
+++ backports-2017-11-01/drivers/net/wireless/realtek/rtkwifiu/rtl8723bs/os_dep/linux/ioctl_cfg80211.c
@@ -3383,7 +3383,7 @@ static int cfg80211_rtw_get_txpower(stru
 #endif
 	int *dbm)
 {
-	RTW_INFO("%s\n", __func__);
+	RTW_DBG("%s\n", __func__);
 
 	*dbm = (12);
 
@@ -4450,13 +4450,13 @@ static int	cfg80211_rtw_dump_station(str
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(ndev);
 	struct sta_info *psta = NULL;
 	struct sta_priv *pstapriv = &padapter->stapriv;
-	RTW_INFO(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
+	RTW_DBG(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
 
 	_enter_critical_bh(&pstapriv->asoc_list_lock, &irqL);
 	psta = rtw_sta_info_get_by_idx(idx, pstapriv);
 	_exit_critical_bh(&pstapriv->asoc_list_lock, &irqL);
 	if (NULL == psta) {
-		RTW_INFO("Station is not found\n");
+		RTW_DBG("Station is not found\n");
 		ret = -ENOENT;
 		goto exit;
 	}
@@ -6901,6 +6901,7 @@ static void rtw_cfg80211_preinit_wiphy(_
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 2, 0))
 	/* wiphy->flags |= WIPHY_FLAG_SUPPORTS_FW_ROAM; */
 #endif
+	 _rtw_memcpy(wiphy->perm_addr, adapter_mac_addr(adapter), ETH_ALEN);
 }
 
 #ifdef CONFIG_RFKILL_POLL
@@ -7074,6 +7075,63 @@ int rtw_hostapd_acs_dump_survey(struct w
 }
 #endif /* defined(CONFIG_RTW_HOSTAPD_ACS) && (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 33)) */
 
+static int cfg80211_rtw_get_channel(struct wiphy *wiphy, struct wireless_dev *wdev, struct cfg80211_chan_def *chandef)
+{
+	_adapter *padapter = wiphy_to_adapter(wiphy);
+	struct dvobj_priv *dvobj = adapter_to_dvobj(padapter);
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
+	struct ieee80211_channel *chan;
+	enum nl80211_band band;
+	int ret = -ENODATA;
+	int freq;
+	u8 center_ch;
+
+	if (pmlmeext->cur_channel > 14)
+		band = NL80211_BAND_5GHZ;
+	else
+		band = NL80211_BAND_2GHZ;
+
+	freq = ieee80211_channel_to_frequency(pmlmeext->cur_channel, band);
+	chan = ieee80211_get_channel(wiphy, freq);
+
+	switch (pmlmeext->cur_bwmode) {
+	case CHANNEL_WIDTH_20:
+		chandef->width = NL80211_CHAN_WIDTH_20;
+		break;
+	case CHANNEL_WIDTH_40:
+		chandef->width = NL80211_CHAN_WIDTH_40;
+		break;
+	case CHANNEL_WIDTH_80:
+		chandef->width = NL80211_CHAN_WIDTH_80;
+		break;
+	case CHANNEL_WIDTH_80_80:
+		chandef->width = NL80211_CHAN_WIDTH_80P80;
+		break;
+	case CHANNEL_WIDTH_160:
+		chandef->width = NL80211_CHAN_WIDTH_160;
+		break;
+	default:
+		WARN_ON(1);
+		break;
+	}
+
+	center_ch = rtw_get_center_ch(pmlmeext->cur_channel, pmlmeext->cur_bwmode, pmlmeext->cur_ch_offset);
+	chandef->chan = chan;
+	chandef->center_freq1 = ieee80211_channel_to_frequency(center_ch, band);
+	chandef->center_freq2 = 0;
+
+	if (cfg80211_chandef_valid(chandef))
+		ret = 0;
+
+	#ifdef CONFIG_DEBUG_CFG80211
+	printk("%s: ret=%d, cur_channel=%d, cur_bwmode=%d, cur_ch_offset=%d, band=%d, center_ch=%d\n",
+		__func__, ret, pmlmeext->cur_channel, pmlmeext->cur_bwmode, pmlmeext->cur_ch_offset, band, center_ch);
+	#endif
+
+	return ret;
+}
+
 static struct cfg80211_ops rtw_cfg80211_ops = {
 	.change_virtual_intf = cfg80211_rtw_change_iface,
 	.add_key = cfg80211_rtw_add_key,
@@ -7170,6 +7228,7 @@ static struct cfg80211_ops rtw_cfg80211_
 #if defined(CONFIG_RTW_HOSTAPD_ACS) && (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 33))
 	.dump_survey = rtw_hostapd_acs_dump_survey,
 #endif
+	.get_channel = cfg80211_rtw_get_channel,
 };
 
 struct wiphy *rtw_wiphy_alloc(_adapter *padapter, struct device *dev)
Index: backports-2017-11-01/drivers/net/wireless/realtek/rtkwifiu/rtl8723ds/os_dep/linux/ioctl_cfg80211.c
===================================================================
--- backports-2017-11-01.orig/drivers/net/wireless/realtek/rtkwifiu/rtl8723ds/os_dep/linux/ioctl_cfg80211.c
+++ backports-2017-11-01/drivers/net/wireless/realtek/rtkwifiu/rtl8723ds/os_dep/linux/ioctl_cfg80211.c
@@ -4089,7 +4089,7 @@ static int cfg80211_rtw_get_txpower(stru
 #endif
 	int *dbm)
 {
-	RTW_INFO("%s\n", __func__);
+	RTW_DBG("%s\n", __func__);
 
 	*dbm = (12);
 
@@ -5642,7 +5642,7 @@ static int	cfg80211_rtw_dump_station(str
 	u8 asoc_list_num;
 
 	if (DBG_DUMP_STATION)
-		RTW_INFO(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
+		RTW_DBG(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
 
 	_enter_critical_bh(&pstapriv->asoc_list_lock, &irqL);
 	psta = rtw_sta_info_get_by_idx(pstapriv, idx, &asoc_list_num);
@@ -5663,7 +5663,7 @@ static int	cfg80211_rtw_dump_station(str
 		#endif
 	) {
 		if (DBG_DUMP_STATION)
-			RTW_INFO(FUNC_NDEV_FMT" end with idx:%d\n", FUNC_NDEV_ARG(ndev), idx);
+			RTW_DBG(FUNC_NDEV_FMT" end with idx:%d\n", FUNC_NDEV_ARG(ndev), idx);
 		ret = -ENOENT;
 		goto exit;
 	}
@@ -9397,6 +9397,7 @@ static void rtw_cfg80211_preinit_wiphy(_
 		;
 #endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 3, 0)) */
 #endif /* CONFIG_RTW_MESH */
+	_rtw_memcpy(wiphy->perm_addr, adapter_mac_addr(adapter), ETH_ALEN);
 }
 
 #ifdef CONFIG_RFKILL_POLL
@@ -9570,6 +9571,63 @@ int rtw_hostapd_acs_dump_survey(struct w
 }
 #endif /* defined(CONFIG_RTW_HOSTAPD_ACS) && (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 33)) */
 
+static int cfg80211_rtw_get_channel(struct wiphy *wiphy, struct wireless_dev *wdev, struct cfg80211_chan_def *chandef)
+{
+	_adapter *padapter = wiphy_to_adapter(wiphy);
+	struct dvobj_priv *dvobj = adapter_to_dvobj(padapter);
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
+	struct ieee80211_channel *chan;
+	enum nl80211_band band;
+	int ret = -ENODATA;
+	int freq;
+	u8 center_ch;
+
+	if (pmlmeext->cur_channel > 14)
+		band = NL80211_BAND_5GHZ;
+	else
+		band = NL80211_BAND_2GHZ;
+
+	freq = ieee80211_channel_to_frequency(pmlmeext->cur_channel, band);
+	chan = ieee80211_get_channel(wiphy, freq);
+
+	switch (pmlmeext->cur_bwmode) {
+	case CHANNEL_WIDTH_20:
+		chandef->width = NL80211_CHAN_WIDTH_20;
+		break;
+	case CHANNEL_WIDTH_40:
+		chandef->width = NL80211_CHAN_WIDTH_40;
+		break;
+	case CHANNEL_WIDTH_80:
+		chandef->width = NL80211_CHAN_WIDTH_80;
+		break;
+	case CHANNEL_WIDTH_80_80:
+		chandef->width = NL80211_CHAN_WIDTH_80P80;
+		break;
+	case CHANNEL_WIDTH_160:
+		chandef->width = NL80211_CHAN_WIDTH_160;
+		break;
+	default:
+		WARN_ON(1);
+		break;
+	}
+
+	center_ch = rtw_get_center_ch(pmlmeext->cur_channel, pmlmeext->cur_bwmode, pmlmeext->cur_ch_offset);
+	chandef->chan = chan;
+	chandef->center_freq1 = ieee80211_channel_to_frequency(center_ch, band);
+	chandef->center_freq2 = 0;
+
+	if (cfg80211_chandef_valid(chandef))
+		ret = 0;
+
+	#ifdef CONFIG_DEBUG_CFG80211
+	printk("%s: ret=%d, cur_channel=%d, cur_bwmode=%d, cur_ch_offset=%d, band=%d, center_ch=%d\n",
+		__func__, ret, pmlmeext->cur_channel, pmlmeext->cur_bwmode, pmlmeext->cur_ch_offset, band, center_ch);
+	#endif
+
+	return ret;
+}
+
 static struct cfg80211_ops rtw_cfg80211_ops = {
 	.change_virtual_intf = cfg80211_rtw_change_iface,
 	.add_key = cfg80211_rtw_add_key,
@@ -9688,6 +9746,7 @@ static struct cfg80211_ops rtw_cfg80211_
 #if defined(CONFIG_RTW_HOSTAPD_ACS) && (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 33))
 	.dump_survey = rtw_hostapd_acs_dump_survey,
 #endif
+	.get_channel = cfg80211_rtw_get_channel,
 };
 
 struct wiphy *rtw_wiphy_alloc(_adapter *padapter, struct device *dev)
Index: backports-2017-11-01/drivers/net/wireless/realtek/rtkwifiu/rtl8821cu/os_dep/linux/ioctl_cfg80211.c
===================================================================
--- backports-2017-11-01.orig/drivers/net/wireless/realtek/rtkwifiu/rtl8821cu/os_dep/linux/ioctl_cfg80211.c
+++ backports-2017-11-01/drivers/net/wireless/realtek/rtkwifiu/rtl8821cu/os_dep/linux/ioctl_cfg80211.c
@@ -4046,7 +4046,7 @@ static int cfg80211_rtw_get_txpower(stru
 #endif
 	int *dbm)
 {
-	RTW_INFO("%s\n", __func__);
+	RTW_DBG("%s\n", __func__);
 
 	*dbm = (12);
 
@@ -5552,7 +5552,7 @@ static int	cfg80211_rtw_dump_station(str
 	u8 asoc_list_num;
 
 	if (DBG_DUMP_STATION)
-		RTW_INFO(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
+		RTW_DBG(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
 
 	_enter_critical_bh(&pstapriv->asoc_list_lock, &irqL);
 	psta = rtw_sta_info_get_by_idx(pstapriv, idx, &asoc_list_num);
@@ -5573,7 +5573,7 @@ static int	cfg80211_rtw_dump_station(str
 		#endif
 	) {
 		if (DBG_DUMP_STATION)
-			RTW_INFO(FUNC_NDEV_FMT" end with idx:%d\n", FUNC_NDEV_ARG(ndev), idx);
+			RTW_DBG(FUNC_NDEV_FMT" end with idx:%d\n", FUNC_NDEV_ARG(ndev), idx);
 		ret = -ENOENT;
 		goto exit;
 	}
@@ -9192,6 +9192,7 @@ static void rtw_cfg80211_preinit_wiphy(_
 		;
 #endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 3, 0)) */
 #endif /* CONFIG_RTW_MESH */
+	_rtw_memcpy(wiphy->perm_addr, adapter_mac_addr(adapter), ETH_ALEN);
 }
 
 #ifdef CONFIG_RFKILL_POLL
@@ -9365,6 +9366,63 @@ int rtw_hostapd_acs_dump_survey(struct w
 }
 #endif /* defined(CONFIG_RTW_HOSTAPD_ACS) && (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 33)) */
 
+static int cfg80211_rtw_get_channel(struct wiphy *wiphy, struct wireless_dev *wdev, struct cfg80211_chan_def *chandef)
+{
+	_adapter *padapter = wiphy_to_adapter(wiphy);
+	struct dvobj_priv *dvobj = adapter_to_dvobj(padapter);
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
+	struct ieee80211_channel *chan;
+	enum nl80211_band band;
+	int ret = -ENODATA;
+	int freq;
+	u8 center_ch;
+
+	if (pmlmeext->cur_channel > 14)
+		band = NL80211_BAND_5GHZ;
+	else
+		band = NL80211_BAND_2GHZ;
+
+	freq = ieee80211_channel_to_frequency(pmlmeext->cur_channel, band);
+	chan = ieee80211_get_channel(wiphy, freq);
+
+	switch (pmlmeext->cur_bwmode) {
+	case CHANNEL_WIDTH_20:
+		chandef->width = NL80211_CHAN_WIDTH_20;
+		break;
+	case CHANNEL_WIDTH_40:
+		chandef->width = NL80211_CHAN_WIDTH_40;
+		break;
+	case CHANNEL_WIDTH_80:
+		chandef->width = NL80211_CHAN_WIDTH_80;
+		break;
+	case CHANNEL_WIDTH_80_80:
+		chandef->width = NL80211_CHAN_WIDTH_80P80;
+		break;
+	case CHANNEL_WIDTH_160:
+		chandef->width = NL80211_CHAN_WIDTH_160;
+		break;
+	default:
+		WARN_ON(1);
+		break;
+	}
+
+	center_ch = rtw_get_center_ch(pmlmeext->cur_channel, pmlmeext->cur_bwmode, pmlmeext->cur_ch_offset);
+	chandef->chan = chan;
+	chandef->center_freq1 = ieee80211_channel_to_frequency(center_ch, band);
+	chandef->center_freq2 = 0;
+
+	if (cfg80211_chandef_valid(chandef))
+		ret = 0;
+
+	#ifdef CONFIG_DEBUG_CFG80211
+	printk("%s: ret=%d, cur_channel=%d, cur_bwmode=%d, cur_ch_offset=%d, band=%d, center_ch=%d\n",
+		__func__, ret, pmlmeext->cur_channel, pmlmeext->cur_bwmode, pmlmeext->cur_ch_offset, band, center_ch);
+	#endif
+
+	return ret;
+}
+
 static struct cfg80211_ops rtw_cfg80211_ops = {
 	.change_virtual_intf = cfg80211_rtw_change_iface,
 	.add_key = cfg80211_rtw_add_key,
@@ -9480,6 +9538,7 @@ static struct cfg80211_ops rtw_cfg80211_
 #if defined(CONFIG_RTW_HOSTAPD_ACS) && (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 33))
 	.dump_survey = rtw_hostapd_acs_dump_survey,
 #endif
+	.get_channel = cfg80211_rtw_get_channel,
 };
 
 struct wiphy *rtw_wiphy_alloc(_adapter *padapter, struct device *dev)
Index: backports-2017-11-01/drivers/net/wireless/realtek/rtkwifiu/rtl8822be/os_dep/linux/ioctl_cfg80211.c
===================================================================
--- backports-2017-11-01.orig/drivers/net/wireless/realtek/rtkwifiu/rtl8822be/os_dep/linux/ioctl_cfg80211.c
+++ backports-2017-11-01/drivers/net/wireless/realtek/rtkwifiu/rtl8822be/os_dep/linux/ioctl_cfg80211.c
@@ -3768,7 +3768,7 @@ static int cfg80211_rtw_get_txpower(stru
 #endif
 	int *dbm)
 {
-	RTW_INFO("%s\n", __func__);
+	RTW_DBG("%s\n", __func__);
 
 	*dbm = (12);
 
@@ -4866,13 +4866,13 @@ static int	cfg80211_rtw_dump_station(str
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(ndev);
 	struct sta_info *psta = NULL;
 	struct sta_priv *pstapriv = &padapter->stapriv;
-	RTW_INFO(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
+	RTW_DBG(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
 
 	_enter_critical_bh(&pstapriv->asoc_list_lock, &irqL);
 	psta = rtw_sta_info_get_by_idx(idx, pstapriv);
 	_exit_critical_bh(&pstapriv->asoc_list_lock, &irqL);
 	if (NULL == psta) {
-		RTW_INFO("Station is not found\n");
+		RTW_DBG("Station is not found\n");
 		ret = -ENOENT;
 		goto exit;
 	}
@@ -7375,6 +7375,7 @@ static void rtw_cfg80211_preinit_wiphy(_
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 2, 0))
 	/* wiphy->flags |= WIPHY_FLAG_SUPPORTS_FW_ROAM; */
 #endif
+	_rtw_memcpy(wiphy->perm_addr, adapter_mac_addr(adapter), ETH_ALEN);
 }
 
 #ifdef CONFIG_RFKILL_POLL
@@ -7548,6 +7549,63 @@ int rtw_hostapd_acs_dump_survey(struct w
 }
 #endif /* defined(CONFIG_RTW_HOSTAPD_ACS) && (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 33)) */
 
+static int cfg80211_rtw_get_channel(struct wiphy *wiphy, struct wireless_dev *wdev, struct cfg80211_chan_def *chandef)
+{
+	_adapter *padapter = wiphy_to_adapter(wiphy);
+	struct dvobj_priv *dvobj = adapter_to_dvobj(padapter);
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
+	struct ieee80211_channel *chan;
+	enum nl80211_band band;
+	int ret = -ENODATA;
+	int freq;
+	u8 center_ch;
+
+	if (pmlmeext->cur_channel > 14)
+		band = NL80211_BAND_5GHZ;
+	else
+		band = NL80211_BAND_2GHZ;
+
+	freq = ieee80211_channel_to_frequency(pmlmeext->cur_channel, band);
+	chan = ieee80211_get_channel(wiphy, freq);
+
+	switch (pmlmeext->cur_bwmode) {
+	case CHANNEL_WIDTH_20:
+		chandef->width = NL80211_CHAN_WIDTH_20;
+		break;
+	case CHANNEL_WIDTH_40:
+		chandef->width = NL80211_CHAN_WIDTH_40;
+		break;
+	case CHANNEL_WIDTH_80:
+		chandef->width = NL80211_CHAN_WIDTH_80;
+		break;
+	case CHANNEL_WIDTH_80_80:
+		chandef->width = NL80211_CHAN_WIDTH_80P80;
+		break;
+	case CHANNEL_WIDTH_160:
+		chandef->width = NL80211_CHAN_WIDTH_160;
+		break;
+	default:
+		WARN_ON(1);
+		break;
+	}
+
+	center_ch = rtw_get_center_ch(pmlmeext->cur_channel, pmlmeext->cur_bwmode, pmlmeext->cur_ch_offset);
+	chandef->chan = chan;
+	chandef->center_freq1 = ieee80211_channel_to_frequency(center_ch, band);
+	chandef->center_freq2 = 0;
+
+	if (cfg80211_chandef_valid(chandef))
+		ret = 0;
+
+	#ifdef CONFIG_DEBUG_CFG80211
+	printk("%s: ret=%d, cur_channel=%d, cur_bwmode=%d, cur_ch_offset=%d, band=%d, center_ch=%d\n",
+		__func__, ret, pmlmeext->cur_channel, pmlmeext->cur_bwmode, pmlmeext->cur_ch_offset, band, center_ch);
+	#endif
+
+	return ret;
+}
+
 static struct cfg80211_ops rtw_cfg80211_ops = {
 	.change_virtual_intf = cfg80211_rtw_change_iface,
 	.add_key = cfg80211_rtw_add_key,
@@ -7644,6 +7702,7 @@ static struct cfg80211_ops rtw_cfg80211_
 #if defined(CONFIG_RTW_HOSTAPD_ACS) && (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 33))
 	.dump_survey = rtw_hostapd_acs_dump_survey,
 #endif
+	.get_channel = cfg80211_rtw_get_channel,
 };
 
 struct wiphy *rtw_wiphy_alloc(_adapter *padapter, struct device *dev)
Index: backports-2017-11-01/drivers/net/wireless/realtek/rtkwifiu/rtl8822bs/os_dep/linux/ioctl_cfg80211.c
===================================================================
--- backports-2017-11-01.orig/drivers/net/wireless/realtek/rtkwifiu/rtl8822bs/os_dep/linux/ioctl_cfg80211.c
+++ backports-2017-11-01/drivers/net/wireless/realtek/rtkwifiu/rtl8822bs/os_dep/linux/ioctl_cfg80211.c
@@ -3932,7 +3932,7 @@ static int cfg80211_rtw_get_txpower(stru
 #endif
 	int *dbm)
 {
-	RTW_INFO("%s\n", __func__);
+	RTW_DBG("%s\n", __func__);
 
 	*dbm = (12);
 
@@ -5030,13 +5030,13 @@ static int	cfg80211_rtw_dump_station(str
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(ndev);
 	struct sta_info *psta = NULL;
 	struct sta_priv *pstapriv = &padapter->stapriv;
-	RTW_INFO(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
+	RTW_DBG(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
 
 	_enter_critical_bh(&pstapriv->asoc_list_lock, &irqL);
 	psta = rtw_sta_info_get_by_idx(idx, pstapriv);
 	_exit_critical_bh(&pstapriv->asoc_list_lock, &irqL);
 	if (NULL == psta) {
-		RTW_INFO("Station is not found\n");
+		RTW_DBG("Station is not found\n");
 		ret = -ENOENT;
 		goto exit;
 	}
@@ -7539,6 +7539,7 @@ static void rtw_cfg80211_preinit_wiphy(_
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 2, 0))
 	/* wiphy->flags |= WIPHY_FLAG_SUPPORTS_FW_ROAM; */
 #endif
+	_rtw_memcpy(wiphy->perm_addr, adapter_mac_addr(adapter), ETH_ALEN);
 }
 
 #ifdef CONFIG_RFKILL_POLL
@@ -7712,6 +7713,63 @@ int rtw_hostapd_acs_dump_survey(struct w
 }
 #endif /* defined(CONFIG_RTW_HOSTAPD_ACS) && (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 33)) */
 
+static int cfg80211_rtw_get_channel(struct wiphy *wiphy, struct wireless_dev *wdev, struct cfg80211_chan_def *chandef)
+{
+	_adapter *padapter = wiphy_to_adapter(wiphy);
+	struct dvobj_priv *dvobj = adapter_to_dvobj(padapter);
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
+	struct ieee80211_channel *chan;
+	enum nl80211_band band;
+	int ret = -ENODATA;
+	int freq;
+	u8 center_ch;
+
+	if (pmlmeext->cur_channel > 14)
+		band = NL80211_BAND_5GHZ;
+	else
+		band = NL80211_BAND_2GHZ;
+
+	freq = ieee80211_channel_to_frequency(pmlmeext->cur_channel, band);
+	chan = ieee80211_get_channel(wiphy, freq);
+
+	switch (pmlmeext->cur_bwmode) {
+	case CHANNEL_WIDTH_20:
+		chandef->width = NL80211_CHAN_WIDTH_20;
+		break;
+	case CHANNEL_WIDTH_40:
+		chandef->width = NL80211_CHAN_WIDTH_40;
+		break;
+	case CHANNEL_WIDTH_80:
+		chandef->width = NL80211_CHAN_WIDTH_80;
+		break;
+	case CHANNEL_WIDTH_80_80:
+		chandef->width = NL80211_CHAN_WIDTH_80P80;
+		break;
+	case CHANNEL_WIDTH_160:
+		chandef->width = NL80211_CHAN_WIDTH_160;
+		break;
+	default:
+		WARN_ON(1);
+		break;
+	}
+
+	center_ch = rtw_get_center_ch(pmlmeext->cur_channel, pmlmeext->cur_bwmode, pmlmeext->cur_ch_offset);
+	chandef->chan = chan;
+	chandef->center_freq1 = ieee80211_channel_to_frequency(center_ch, band);
+	chandef->center_freq2 = 0;
+
+	if (cfg80211_chandef_valid(chandef))
+		ret = 0;
+
+	#ifdef CONFIG_DEBUG_CFG80211
+	printk("%s: ret=%d, cur_channel=%d, cur_bwmode=%d, cur_ch_offset=%d, band=%d, center_ch=%d\n",
+		__func__, ret, pmlmeext->cur_channel, pmlmeext->cur_bwmode, pmlmeext->cur_ch_offset, band, center_ch);
+	#endif
+
+	return ret;
+}
+
 static struct cfg80211_ops rtw_cfg80211_ops = {
 	.change_virtual_intf = cfg80211_rtw_change_iface,
 	.add_key = cfg80211_rtw_add_key,
@@ -7808,6 +7866,7 @@ static struct cfg80211_ops rtw_cfg80211_
 #if defined(CONFIG_RTW_HOSTAPD_ACS) && (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 33))
 	.dump_survey = rtw_hostapd_acs_dump_survey,
 #endif
+	.get_channel = cfg80211_rtw_get_channel,
 };
 
 struct wiphy *rtw_wiphy_alloc(_adapter *padapter, struct device *dev)
Index: backports-2017-11-01/drivers/net/wireless/realtek/rtkwifiu/rtl8822bu/os_dep/linux/ioctl_cfg80211.c
===================================================================
--- backports-2017-11-01.orig/drivers/net/wireless/realtek/rtkwifiu/rtl8822bu/os_dep/linux/ioctl_cfg80211.c
+++ backports-2017-11-01/drivers/net/wireless/realtek/rtkwifiu/rtl8822bu/os_dep/linux/ioctl_cfg80211.c
@@ -4081,7 +4081,7 @@ static int cfg80211_rtw_get_txpower(stru
 #endif
 	int *dbm)
 {
-	RTW_INFO("%s\n", __func__);
+	RTW_DBG("%s\n", __func__);
 
 	*dbm = (12);
 
@@ -5634,7 +5634,7 @@ static int	cfg80211_rtw_dump_station(str
 	u8 asoc_list_num;
 
 	if (DBG_DUMP_STATION)
-		RTW_INFO(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
+		RTW_DBG(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
 
 	_enter_critical_bh(&pstapriv->asoc_list_lock, &irqL);
 	psta = rtw_sta_info_get_by_idx(pstapriv, idx, &asoc_list_num);
@@ -5655,7 +5655,7 @@ static int	cfg80211_rtw_dump_station(str
 		#endif
 	) {
 		if (DBG_DUMP_STATION)
-			RTW_INFO(FUNC_NDEV_FMT" end with idx:%d\n", FUNC_NDEV_ARG(ndev), idx);
+			RTW_DBG(FUNC_NDEV_FMT" end with idx:%d\n", FUNC_NDEV_ARG(ndev), idx);
 		ret = -ENOENT;
 		goto exit;
 	}
@@ -9374,6 +9374,7 @@ static void rtw_cfg80211_preinit_wiphy(_
 		;
 #endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 3, 0)) */
 #endif /* CONFIG_RTW_MESH */
+	_rtw_memcpy(wiphy->perm_addr, adapter_mac_addr(adapter), ETH_ALEN);
 }
 
 #ifdef CONFIG_RFKILL_POLL
@@ -9547,6 +9548,63 @@ int rtw_hostapd_acs_dump_survey(struct w
 }
 #endif /* defined(CONFIG_RTW_HOSTAPD_ACS) && (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 33)) */
 
+static int cfg80211_rtw_get_channel(struct wiphy *wiphy, struct wireless_dev *wdev, struct cfg80211_chan_def *chandef)
+{
+	_adapter *padapter = wiphy_to_adapter(wiphy);
+	struct dvobj_priv *dvobj = adapter_to_dvobj(padapter);
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
+	struct ieee80211_channel *chan;
+	enum nl80211_band band;
+	int ret = -ENODATA;
+	int freq;
+	u8 center_ch;
+
+	if (pmlmeext->cur_channel > 14)
+		band = NL80211_BAND_5GHZ;
+	else
+		band = NL80211_BAND_2GHZ;
+
+	freq = ieee80211_channel_to_frequency(pmlmeext->cur_channel, band);
+	chan = ieee80211_get_channel(wiphy, freq);
+
+	switch (pmlmeext->cur_bwmode) {
+	case CHANNEL_WIDTH_20:
+		chandef->width = NL80211_CHAN_WIDTH_20;
+		break;
+	case CHANNEL_WIDTH_40:
+		chandef->width = NL80211_CHAN_WIDTH_40;
+		break;
+	case CHANNEL_WIDTH_80:
+		chandef->width = NL80211_CHAN_WIDTH_80;
+		break;
+	case CHANNEL_WIDTH_80_80:
+		chandef->width = NL80211_CHAN_WIDTH_80P80;
+		break;
+	case CHANNEL_WIDTH_160:
+		chandef->width = NL80211_CHAN_WIDTH_160;
+		break;
+	default:
+		WARN_ON(1);
+		break;
+	}
+
+	center_ch = rtw_get_center_ch(pmlmeext->cur_channel, pmlmeext->cur_bwmode, pmlmeext->cur_ch_offset);
+	chandef->chan = chan;
+	chandef->center_freq1 = ieee80211_channel_to_frequency(center_ch, band);
+	chandef->center_freq2 = 0;
+
+	if (cfg80211_chandef_valid(chandef))
+		ret = 0;
+
+	#ifdef CONFIG_DEBUG_CFG80211
+	printk("%s: ret=%d, cur_channel=%d, cur_bwmode=%d, cur_ch_offset=%d, band=%d, center_ch=%d\n",
+		__func__, ret, pmlmeext->cur_channel, pmlmeext->cur_bwmode, pmlmeext->cur_ch_offset, band, center_ch);
+	#endif
+
+	return ret;
+}
+
 static struct cfg80211_ops rtw_cfg80211_ops = {
 	.change_virtual_intf = cfg80211_rtw_change_iface,
 	.add_key = cfg80211_rtw_add_key,
@@ -9665,6 +9723,7 @@ static struct cfg80211_ops rtw_cfg80211_
 #if defined(CONFIG_RTW_HOSTAPD_ACS) && (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 33))
 	.dump_survey = rtw_hostapd_acs_dump_survey,
 #endif
+	.get_channel = cfg80211_rtw_get_channel,
 };
 
 struct wiphy *rtw_wiphy_alloc(_adapter *padapter, struct device *dev)
Index: backports-2017-11-01/drivers/net/wireless/realtek/rtkwifiu/rtl8821ce/Makefile
===================================================================
--- backports-2017-11-01.orig/drivers/net/wireless/realtek/rtkwifiu/rtl8821ce/Makefile
+++ backports-2017-11-01/drivers/net/wireless/realtek/rtkwifiu/rtl8821ce/Makefile
@@ -208,6 +208,7 @@ _HAL_INTFS_FILES :=	hal/hal_intf.o \
 			hal/hal_com_phycfg.o \
 			hal/hal_phy.o \
 			hal/hal_dm.o \
+			hal/hal_dm_acs.o \
 			hal/hal_btcoex_wifionly.o \
 			hal/hal_btcoex.o \
 			hal/hal_mp.o \
Index: backports-2017-11-01/drivers/net/wireless/realtek/rtkwifiu/rtl8821ce/include/hal_data.h
===================================================================
--- backports-2017-11-01.orig/drivers/net/wireless/realtek/rtkwifiu/rtl8821ce/include/hal_data.h
+++ backports-2017-11-01/drivers/net/wireless/realtek/rtkwifiu/rtl8821ce/include/hal_data.h
@@ -33,6 +33,11 @@
 #ifdef CONFIG_GSPI_HCI
 	#include <hal_gspi.h>
 #endif
+
+#if defined(CONFIG_RTW_ACS) || defined(CONFIG_BACKGROUND_NOISE_MONITOR)
+#include "../hal/hal_dm_acs.h"
+#endif
+
 /*
  * <Roger_Notes> For RTL8723 WiFi/BT/GPS multi-function configuration. 2010.10.06.
  *   */
Index: backports-2017-11-01/drivers/net/wireless/realtek/rtkwifiu/rtl8821ce/os_dep/linux/ioctl_cfg80211.c
===================================================================
--- backports-2017-11-01.orig/drivers/net/wireless/realtek/rtkwifiu/rtl8821ce/os_dep/linux/ioctl_cfg80211.c
+++ backports-2017-11-01/drivers/net/wireless/realtek/rtkwifiu/rtl8821ce/os_dep/linux/ioctl_cfg80211.c
@@ -3374,7 +3374,7 @@ static int cfg80211_rtw_get_txpower(stru
 #endif
 	int *dbm)
 {
-	RTW_INFO("%s\n", __func__);
+	RTW_DBG("%s\n", __func__);
 
 	*dbm = (12);
 
@@ -4440,13 +4440,13 @@ static int	cfg80211_rtw_dump_station(str
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(ndev);
 	struct sta_info *psta = NULL;
 	struct sta_priv *pstapriv = &padapter->stapriv;
-	RTW_INFO(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
+	RTW_DBG(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
 
 	_enter_critical_bh(&pstapriv->asoc_list_lock, &irqL);
 	psta = rtw_sta_info_get_by_idx(idx, pstapriv);
 	_exit_critical_bh(&pstapriv->asoc_list_lock, &irqL);
 	if (NULL == psta) {
-		RTW_INFO("Station is not found\n");
+		RTW_DBG("Station is not found\n");
 		ret = -ENOENT;
 		goto exit;
 	}
@@ -6852,6 +6852,201 @@ static void rtw_cfg80211_preinit_wiphy(_
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 2, 0))
 	/* wiphy->flags |= WIPHY_FLAG_SUPPORTS_FW_ROAM; */
 #endif
+	_rtw_memcpy(wiphy->perm_addr, adapter_mac_addr(adapter), ETH_ALEN);
+}
+
+#if defined(CONFIG_RTW_HOSTAPD_ACS) && (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 33))
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37)) && (LINUX_VERSION_CODE < KERNEL_VERSION(4, 0, 0))
+#define SURVEY_INFO_TIME			SURVEY_INFO_CHANNEL_TIME
+#define SURVEY_INFO_TIME_BUSY		SURVEY_INFO_CHANNEL_TIME_BUSY
+#define SURVEY_INFO_TIME_EXT_BUSY	SURVEY_INFO_CHANNEL_TIME_EXT_BUSY
+#define SURVEY_INFO_TIME_RX			SURVEY_INFO_CHANNEL_TIME_RX
+#define SURVEY_INFO_TIME_TX			SURVEY_INFO_CHANNEL_TIME_TX
+#endif
+
+#ifdef CONFIG_FIND_BEST_CHANNEL
+static void rtw_cfg80211_set_survey_info_with_find_best_channel(struct wiphy *wiphy
+	, struct net_device *netdev, int idx, struct survey_info *info)
+{
+	_adapter *adapter = (_adapter *)rtw_netdev_priv(netdev);
+	struct rf_ctl_t *rfctl = adapter_to_rfctl(adapter);
+	RT_CHANNEL_INFO *ch_set = rfctl->channel_set;
+	u8 ch_num = rfctl->max_chan_nums;
+	u32 total_rx_cnt = 0;
+	int i;
+
+	s8 noise = -50;		/*channel noise in dBm. This and all following fields are optional */
+	u64 time = 100;		/*amount of time in ms the radio was turn on (on the channel)*/
+	u64 time_busy = 0;	/*amount of time the primary channel was sensed busy*/
+
+	info->filled  = SURVEY_INFO_NOISE_DBM
+		#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37))
+		| SURVEY_INFO_TIME | SURVEY_INFO_TIME_BUSY
+		#endif
+		;
+
+	for (i = 0; i < ch_num; i++)
+		total_rx_cnt += ch_set[i].rx_count;
+
+	time_busy = ch_set[idx].rx_count * time / total_rx_cnt;
+	noise += ch_set[idx].rx_count * 50 / total_rx_cnt;
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37))
+	#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 0, 0))
+	info->channel_time = time;
+	info->channel_time_busy = time_busy;
+	#else
+	info->time = time;
+	info->time_busy = time_busy;
+	#endif
+#endif
+	info->noise = noise;
+
+	/* reset if final channel is got */
+	if (idx == ch_num - 1) {
+		for (i = 0; i < ch_num; i++)
+			ch_set[i].rx_count = 0;
+	}
+}
+#endif /* CONFIG_FIND_BEST_CHANNEL */
+
+#if defined(CONFIG_RTW_ACS) && defined(CONFIG_BACKGROUND_NOISE_MONITOR)
+static void rtw_cfg80211_set_survey_info_with_clm(PADAPTER padapter, int idx, struct survey_info *pinfo)
+{
+	s8 noise = -50;			/*channel noise in dBm. This and all following fields are optional */
+	u64 time = SURVEY_TO;	/*amount of time in ms the radio was turn on (on the channel)*/
+	u64 time_busy = 0;		/*amount of time the primary channel was sensed busy*/
+	u8 chan = (u8)idx;
+
+	if ((idx < 0) || (pinfo == NULL))
+		return;
+
+	pinfo->filled  = SURVEY_INFO_NOISE_DBM
+		#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37))
+		| SURVEY_INFO_TIME | SURVEY_INFO_TIME_BUSY
+		#endif
+		;
+
+	time_busy = rtw_acs_get_clm_ratio_by_ch_idx(padapter, chan);
+	noise = rtw_noise_query_by_chan_idx(padapter, chan);
+	/* RTW_INFO("%s: ch-idx:%d time=%llu(ms), time_busy=%llu(ms), noise=%d(dbm)\n", __func__, idx, time, time_busy, noise); */
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37))
+	#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 0, 0))
+	pinfo->channel_time = time;
+	pinfo->channel_time_busy = time_busy;
+	#else
+	pinfo->time = time;
+	pinfo->time_busy = time_busy;
+	#endif
+#endif
+	pinfo->noise = noise;
+}
+#endif
+
+int rtw_hostapd_acs_dump_survey(struct wiphy *wiphy, struct net_device *netdev, int idx, struct survey_info *info)
+{
+	PADAPTER padapter = (_adapter *)rtw_netdev_priv(netdev);
+	struct rf_ctl_t *rfctl = adapter_to_rfctl(padapter);
+	RT_CHANNEL_INFO *pch_set = rfctl->channel_set;
+	u8 max_chan_nums = rfctl->max_chan_nums;
+	u32 freq = 0;
+	u8 ret = 0;
+	u16 channel = 0;
+
+	if (!netdev || !info) {
+		RTW_INFO("%s: invial parameters.\n", __func__);
+		return -EINVAL;
+	}
+
+	_rtw_memset(info, 0, sizeof(struct survey_info));
+	if (padapter->bup == _FALSE) {
+		RTW_INFO("%s: net device is down.\n", __func__);
+		return -EIO;
+	}
+
+	if (idx >= max_chan_nums)
+		return -ENOENT;
+
+	channel = pch_set[idx].ChannelNum;
+	freq = rtw_ch2freq(channel);
+	info->channel = ieee80211_get_channel(wiphy, freq);
+	/* RTW_INFO("%s: channel %d, freq %d\n", __func__, channel, freq); */
+
+	if (!info->channel)
+		return -EINVAL;
+
+	if (info->channel->flags == IEEE80211_CHAN_DISABLED)
+		return ret;
+
+#ifdef CONFIG_FIND_BEST_CHANNEL
+	rtw_cfg80211_set_survey_info_with_find_best_channel(wiphy, netdev, idx, info);
+#elif defined(CONFIG_RTW_ACS) && defined(CONFIG_BACKGROUND_NOISE_MONITOR)
+	rtw_cfg80211_set_survey_info_with_clm(padapter, idx, info);
+#else
+	RTW_ERR("%s: unknown acs operation!\n", __func__);
+#endif
+
+	return ret;
+}
+#endif /* defined(CONFIG_RTW_HOSTAPD_ACS) && (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 33)) */
+
+static int cfg80211_rtw_get_channel(struct wiphy *wiphy, struct wireless_dev *wdev, struct cfg80211_chan_def *chandef)
+{
+	_adapter *padapter = wiphy_to_adapter(wiphy);
+	struct dvobj_priv *dvobj = adapter_to_dvobj(padapter);
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
+	struct ieee80211_channel *chan;
+	enum nl80211_band band;
+	int ret = -ENODATA;
+	int freq;
+	u8 center_ch;
+
+	if (pmlmeext->cur_channel > 14)
+		band = NL80211_BAND_5GHZ;
+	else
+		band = NL80211_BAND_2GHZ;
+
+	freq = ieee80211_channel_to_frequency(pmlmeext->cur_channel, band);
+	chan = ieee80211_get_channel(wiphy, freq);
+
+	switch (pmlmeext->cur_bwmode) {
+	case CHANNEL_WIDTH_20:
+		chandef->width = NL80211_CHAN_WIDTH_20;
+		break;
+	case CHANNEL_WIDTH_40:
+		chandef->width = NL80211_CHAN_WIDTH_40;
+		break;
+	case CHANNEL_WIDTH_80:
+		chandef->width = NL80211_CHAN_WIDTH_80;
+		break;
+	case CHANNEL_WIDTH_80_80:
+		chandef->width = NL80211_CHAN_WIDTH_80P80;
+		break;
+	case CHANNEL_WIDTH_160:
+		chandef->width = NL80211_CHAN_WIDTH_160;
+		break;
+	default:
+		WARN_ON(1);
+		break;
+	}
+
+	center_ch = rtw_get_center_ch(pmlmeext->cur_channel, pmlmeext->cur_bwmode, pmlmeext->cur_ch_offset);
+	chandef->chan = chan;
+	chandef->center_freq1 = ieee80211_channel_to_frequency(center_ch, band);
+	chandef->center_freq2 = 0;
+
+	if (cfg80211_chandef_valid(chandef))
+		ret = 0;
+
+	#ifdef CONFIG_DEBUG_CFG80211
+	printk("%s: ret=%d, cur_channel=%d, cur_bwmode=%d, cur_ch_offset=%d, band=%d, center_ch=%d\n",
+		__func__, ret, pmlmeext->cur_channel, pmlmeext->cur_bwmode, pmlmeext->cur_ch_offset, band, center_ch);
+	#endif
+
+	return ret;
 }
 
 static struct cfg80211_ops rtw_cfg80211_ops = {
@@ -6942,6 +7137,10 @@ static struct cfg80211_ops rtw_cfg80211_
 	.sched_scan_start = cfg80211_rtw_sched_scan_start,
 	.sched_scan_stop = cfg80211_rtw_sched_scan_stop,
 #endif /* CONFIG_PNO_SUPPORT */
+#if defined(CONFIG_RTW_HOSTAPD_ACS) && (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 33))
+	.dump_survey = rtw_hostapd_acs_dump_survey,
+#endif
+	.get_channel = cfg80211_rtw_get_channel,
 };
 
 struct wiphy *rtw_wiphy_alloc(_adapter *padapter, struct device *dev)
Index: backports-2017-11-01/drivers/net/wireless/realtek/rtkwifiu/rtl8812bu/os_dep/linux/ioctl_cfg80211.c
===================================================================
--- backports-2017-11-01.orig/drivers/net/wireless/realtek/rtkwifiu/rtl8812bu/os_dep/linux/ioctl_cfg80211.c
+++ backports-2017-11-01/drivers/net/wireless/realtek/rtkwifiu/rtl8812bu/os_dep/linux/ioctl_cfg80211.c
@@ -3240,7 +3240,7 @@ static int cfg80211_rtw_get_txpower(stru
 #endif
 	int *dbm)
 {
-	RTW_INFO("%s\n", __func__);
+	RTW_DBG("%s\n", __func__);
 
 	*dbm = (12);
 
@@ -4262,13 +4262,13 @@ static int	cfg80211_rtw_dump_station(str
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(ndev);
 	struct sta_info *psta = NULL;
 	struct sta_priv *pstapriv = &padapter->stapriv;
-	RTW_INFO(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
+	RTW_DBG(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
 
 	_enter_critical_bh(&pstapriv->asoc_list_lock, &irqL);
 	psta = rtw_sta_info_get_by_idx(idx, pstapriv);
 	_exit_critical_bh(&pstapriv->asoc_list_lock, &irqL);
 	if (NULL == psta) {
-		RTW_INFO("Station is not found\n");
+		RTW_DBG("Station is not found\n");
 		ret = -ENOENT;
 		goto exit;
 	}
@@ -5705,6 +5705,173 @@ static int cfg80211_rtw_sched_scan_stop(
 	return rtw_android_pno_enable(dev, _FALSE);
 }
 #endif /* CONFIG_PNO_SUPPORT */
+#ifdef CONFIG_FIND_BEST_CHANNEL
+static int get_best_channel(_adapter *padapter, enum nl80211_band band)
+{
+	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
+	u32 i, best_channel_24G = 1, best_channel_5G = 36, index_24G = 0, index_5G = 0;
+
+	for (i=0; pmlmeext->channel_set[i].ChannelNum !=0; i++) {
+		if ( pmlmeext->channel_set[i].ChannelNum == 1)
+			index_24G = i;
+		if ( pmlmeext->channel_set[i].ChannelNum == 36)
+			index_5G = i;
+	}
+
+	for (i=0; (i < MAX_CHANNEL_NUM) && (pmlmeext->channel_set[i].ChannelNum !=0) ; i++) {
+		if (pmlmeext->channel_set[i].ScanType == SCAN_PASSIVE)
+			continue;
+		// 2.4G
+		if ( pmlmeext->channel_set[i].ChannelNum == 6 || pmlmeext->channel_set[i].ChannelNum == 11) {
+			if ( pmlmeext->channel_set[i].rx_count < pmlmeext->channel_set[index_24G].rx_count ) {
+				index_24G = i;
+				best_channel_24G = pmlmeext->channel_set[i].ChannelNum;
+			}
+		}
+
+		// 5G
+		if ( pmlmeext->channel_set[i].ChannelNum >= 36
+			&& pmlmeext->channel_set[i].ChannelNum < 140 ) {
+			// Find primary channel
+			if ( (( pmlmeext->channel_set[i].ChannelNum - 36) % 8 == 0)
+				&& (pmlmeext->channel_set[i].rx_count < pmlmeext->channel_set[index_5G].rx_count) ) {
+				index_5G = i;
+				best_channel_5G = pmlmeext->channel_set[i].ChannelNum;
+			}
+		}
+
+		if ( pmlmeext->channel_set[i].ChannelNum >= 149
+			&& pmlmeext->channel_set[i].ChannelNum < 165) {
+			// find primary channel
+			if ( (( pmlmeext->channel_set[i].ChannelNum - 149) % 8 == 0)
+				&& (pmlmeext->channel_set[i].rx_count < pmlmeext->channel_set[index_5G].rx_count) ) {
+				index_5G = i;
+				best_channel_5G = pmlmeext->channel_set[i].ChannelNum;
+			}
+		}
+	}
+
+	if (band == NL80211_BAND_2GHZ)
+		return best_channel_24G;
+
+	return best_channel_5G;
+}
+#endif
+
+static int cfg80211_rtw_dump_survey(struct wiphy *wiphy, struct net_device *dev, int idx, struct survey_info *survey)
+{
+	_adapter *padapter = wiphy_to_adapter(wiphy);
+	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
+	struct ss_res *ss = &pmlmeext->sitesurvey_res;
+	struct rtw_ieee80211_channel *ch;
+	struct ieee80211_supported_band *sband=NULL;
+	int freq, band=0;
+	int best_ch = -1;
+
+	if (idx >= ss->ch_num)
+		return -EINVAL;
+
+	ch = &ss->ch[idx];
+
+	if (!ch)
+		return -EINVAL;
+
+	if (ch->hw_value > 14)
+		band = NL80211_BAND_5GHZ;
+	else
+		band = NL80211_BAND_2GHZ;
+
+	sband = wiphy->bands[band];
+
+	if(!sband) {
+		printk("%s under unknown band!!\n",dev->name);
+		return -EINVAL;
+	}
+
+	if(sband->band == NL80211_BAND_2GHZ)
+		freq = ieee80211_channel_to_frequency(ch->hw_value, NL80211_BAND_2GHZ);
+	else
+		freq = ieee80211_channel_to_frequency(ch->hw_value, NL80211_BAND_5GHZ);
+
+	survey->channel = ieee80211_get_channel(wiphy, freq);
+	#ifdef CONFIG_FIND_BEST_CHANNEL
+	best_ch = get_best_channel(padapter, sband->band);
+	#endif
+
+	if (best_ch == ch->hw_value)
+		survey->noise = -100;
+	else
+		survey->noise = -50;
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4,0,0))
+	survey->time = 100;
+	survey->time_busy = 50;
+	survey->filled = SURVEY_INFO_NOISE_DBM | SURVEY_INFO_TIME | SURVEY_INFO_TIME_BUSY;
+#else
+	survey->channel_time = 100;
+	survey->channel_time_busy = 50
+	survey->filled = SURVEY_INFO_NOISE_DBM | SURVEY_INFO_CHANNEL_TIME | SURVEY_INFO_CHANNEL_TIME_BUSY;
+#endif
+
+	return 0;
+}
+
+static int cfg80211_rtw_get_channel(struct wiphy *wiphy, struct wireless_dev *wdev, struct cfg80211_chan_def *chandef)
+{
+	_adapter *padapter = wiphy_to_adapter(wiphy);
+	struct dvobj_priv *dvobj = adapter_to_dvobj(padapter);
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
+	struct ieee80211_channel *chan;
+	enum nl80211_band band;
+	int ret = -ENODATA;
+	int freq;
+	u8 center_ch;
+
+	if (pmlmeext->cur_channel > 14)
+		band = NL80211_BAND_5GHZ;
+	else
+		band = NL80211_BAND_2GHZ;
+
+	freq = ieee80211_channel_to_frequency(pmlmeext->cur_channel, band);
+	chan = ieee80211_get_channel(wiphy, freq);
+
+	switch (pmlmeext->cur_bwmode) {
+	case CHANNEL_WIDTH_20:
+		chandef->width = NL80211_CHAN_WIDTH_20;
+		break;
+	case CHANNEL_WIDTH_40:
+		chandef->width = NL80211_CHAN_WIDTH_40;
+		break;
+	case CHANNEL_WIDTH_80:
+		chandef->width = NL80211_CHAN_WIDTH_80;
+		break;
+	case CHANNEL_WIDTH_80_80:
+		chandef->width = NL80211_CHAN_WIDTH_80P80;
+		break;
+	case CHANNEL_WIDTH_160:
+		chandef->width = NL80211_CHAN_WIDTH_160;
+		break;
+	default:
+		WARN_ON(1);
+		break;
+	}
+
+	center_ch = rtw_get_center_ch(pmlmeext->cur_channel, pmlmeext->cur_bwmode, pmlmeext->cur_ch_offset);
+	chandef->chan = chan;
+	chandef->center_freq1 = ieee80211_channel_to_frequency(center_ch, band);
+	chandef->center_freq2 = 0;
+
+	if (cfg80211_chandef_valid(chandef))
+		ret = 0;
+
+	#ifdef CONFIG_DEBUG_CFG80211
+	printk("%s: ret=%d, cur_channel=%d, cur_bwmode=%d, cur_ch_offset=%d, band=%d, center_ch=%d\n",
+		__func__, ret, pmlmeext->cur_channel, pmlmeext->cur_bwmode, pmlmeext->cur_ch_offset, band, center_ch);
+	#endif
+
+	return ret;
+}
 
 static int rtw_cfg80211_set_beacon_wpsp2pie(struct net_device *ndev, char *buf, int len)
 {
@@ -6371,6 +6538,7 @@ static void rtw_cfg80211_preinit_wiphy(_
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 2, 0))
 	/* wiphy->flags |= WIPHY_FLAG_SUPPORTS_FW_ROAM; */
 #endif
+	_rtw_memcpy(wiphy->perm_addr, adapter_mac_addr(adapter), ETH_ALEN);
 }
 
 static struct cfg80211_ops rtw_cfg80211_ops = {
@@ -6457,6 +6625,8 @@ static struct cfg80211_ops rtw_cfg80211_
 	.sched_scan_start = cfg80211_rtw_sched_scan_start,
 	.sched_scan_stop = cfg80211_rtw_sched_scan_stop,
 #endif /* CONFIG_PNO_SUPPORT */
+	.dump_survey = cfg80211_rtw_dump_survey,
+	.get_channel = cfg80211_rtw_get_channel,
 };
 
 struct wiphy *rtw_wiphy_alloc(_adapter *padapter, struct device *dev)
Index: backports-2017-11-01/drivers/net/wireless/realtek/rtkwifiu/rtl8192ee/os_dep/linux/ioctl_cfg80211.c
===================================================================
--- backports-2017-11-01.orig/drivers/net/wireless/realtek/rtkwifiu/rtl8192ee/os_dep/linux/ioctl_cfg80211.c
+++ backports-2017-11-01/drivers/net/wireless/realtek/rtkwifiu/rtl8192ee/os_dep/linux/ioctl_cfg80211.c
@@ -3616,7 +3616,7 @@ static int cfg80211_rtw_get_txpower(stru
 #endif
 	int *dbm)
 {
-	RTW_INFO("%s\n", __func__);
+	RTW_DBG("%s\n", __func__);
 
 	*dbm = (12);
 
@@ -4683,13 +4683,13 @@ static int	cfg80211_rtw_dump_station(str
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(ndev);
 	struct sta_info *psta = NULL;
 	struct sta_priv *pstapriv = &padapter->stapriv;
-	RTW_INFO(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
+	RTW_DBG(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
 
 	_enter_critical_bh(&pstapriv->asoc_list_lock, &irqL);
 	psta = rtw_sta_info_get_by_idx(idx, pstapriv);
 	_exit_critical_bh(&pstapriv->asoc_list_lock, &irqL);
 	if (NULL == psta) {
-		RTW_INFO("Station is not found\n");
+		RTW_DBG("Station is not found\n");
 		ret = -ENOENT;
 		goto exit;
 	}
@@ -7110,6 +7110,7 @@ static void rtw_cfg80211_preinit_wiphy(_
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 2, 0))
 	/* wiphy->flags |= WIPHY_FLAG_SUPPORTS_FW_ROAM; */
 #endif
+	_rtw_memcpy(wiphy->perm_addr, adapter_mac_addr(adapter), ETH_ALEN);
 }
 
 #ifdef CONFIG_RFKILL_POLL
@@ -7283,6 +7284,63 @@ int rtw_hostapd_acs_dump_survey(struct w
 }
 #endif /* defined(CONFIG_RTW_HOSTAPD_ACS) && (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 33)) */
 
+static int cfg80211_rtw_get_channel(struct wiphy *wiphy, struct wireless_dev *wdev, struct cfg80211_chan_def *chandef)
+{
+	_adapter *padapter = wiphy_to_adapter(wiphy);
+	struct dvobj_priv *dvobj = adapter_to_dvobj(padapter);
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
+	struct ieee80211_channel *chan;
+	enum nl80211_band band;
+	int ret = -ENODATA;
+	int freq;
+	u8 center_ch;
+
+	if (pmlmeext->cur_channel > 14)
+		band = NL80211_BAND_5GHZ;
+	else
+		band = NL80211_BAND_2GHZ;
+
+	freq = ieee80211_channel_to_frequency(pmlmeext->cur_channel, band);
+	chan = ieee80211_get_channel(wiphy, freq);
+
+	switch (pmlmeext->cur_bwmode) {
+	case CHANNEL_WIDTH_20:
+		chandef->width = NL80211_CHAN_WIDTH_20;
+		break;
+	case CHANNEL_WIDTH_40:
+		chandef->width = NL80211_CHAN_WIDTH_40;
+		break;
+	case CHANNEL_WIDTH_80:
+		chandef->width = NL80211_CHAN_WIDTH_80;
+		break;
+	case CHANNEL_WIDTH_80_80:
+		chandef->width = NL80211_CHAN_WIDTH_80P80;
+		break;
+	case CHANNEL_WIDTH_160:
+		chandef->width = NL80211_CHAN_WIDTH_160;
+		break;
+	default:
+		WARN_ON(1);
+		break;
+	}
+
+	center_ch = rtw_get_center_ch(pmlmeext->cur_channel, pmlmeext->cur_bwmode, pmlmeext->cur_ch_offset);
+	chandef->chan = chan;
+	chandef->center_freq1 = ieee80211_channel_to_frequency(center_ch, band);
+	chandef->center_freq2 = 0;
+
+	if (cfg80211_chandef_valid(chandef))
+		ret = 0;
+
+	#ifdef CONFIG_DEBUG_CFG80211
+	printk("%s: ret=%d, cur_channel=%d, cur_bwmode=%d, cur_ch_offset=%d, band=%d, center_ch=%d\n",
+		__func__, ret, pmlmeext->cur_channel, pmlmeext->cur_bwmode, pmlmeext->cur_ch_offset, band, center_ch);
+	#endif
+
+	return ret;
+}
+
 static struct cfg80211_ops rtw_cfg80211_ops = {
 	.change_virtual_intf = cfg80211_rtw_change_iface,
 	.add_key = cfg80211_rtw_add_key,
@@ -7379,6 +7437,7 @@ static struct cfg80211_ops rtw_cfg80211_
 #if defined(CONFIG_RTW_HOSTAPD_ACS) && (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 33))
 	.dump_survey = rtw_hostapd_acs_dump_survey,
 #endif
+	.get_channel = cfg80211_rtw_get_channel,
 };
 
 struct wiphy *rtw_wiphy_alloc(_adapter *padapter, struct device *dev)
Index: backports-2017-11-01/drivers/net/wireless/realtek/rtkwifiu/rtl8822ce/os_dep/linux/ioctl_cfg80211.c
===================================================================
--- backports-2017-11-01.orig/drivers/net/wireless/realtek/rtkwifiu/rtl8822ce/os_dep/linux/ioctl_cfg80211.c
+++ backports-2017-11-01/drivers/net/wireless/realtek/rtkwifiu/rtl8822ce/os_dep/linux/ioctl_cfg80211.c
@@ -4080,7 +4080,7 @@ static int cfg80211_rtw_get_txpower(stru
 #endif
 	int *dbm)
 {
-	RTW_INFO("%s\n", __func__);
+	RTW_DBG("%s\n", __func__);
 
 	*dbm = (12);
 
@@ -5635,7 +5635,7 @@ static int	cfg80211_rtw_dump_station(str
 	u8 asoc_list_num;
 
 	if (DBG_DUMP_STATION)
-		RTW_INFO(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
+		RTW_DBG(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
 
 	_enter_critical_bh(&pstapriv->asoc_list_lock, &irqL);
 	psta = rtw_sta_info_get_by_idx(pstapriv, idx, &asoc_list_num);
@@ -5656,7 +5656,7 @@ static int	cfg80211_rtw_dump_station(str
 		#endif
 	) {
 		if (DBG_DUMP_STATION)
-			RTW_INFO(FUNC_NDEV_FMT" end with idx:%d\n", FUNC_NDEV_ARG(ndev), idx);
+			RTW_DBG(FUNC_NDEV_FMT" end with idx:%d\n", FUNC_NDEV_ARG(ndev), idx);
 		ret = -ENOENT;
 		goto exit;
 	}
@@ -9368,7 +9368,7 @@ static void rtw_cfg80211_preinit_wiphy(_
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 2, 0))
 	/* wiphy->flags |= WIPHY_FLAG_SUPPORTS_FW_ROAM; */
 #endif
-
+	_rtw_memcpy(wiphy->perm_addr, adapter_mac_addr(adapter), ETH_ALEN);
 #ifdef CONFIG_RTW_MESH
 	wiphy->flags |= 0
 		#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37))
@@ -9560,6 +9560,63 @@ int rtw_hostapd_acs_dump_survey(struct w
 }
 #endif /* defined(CONFIG_RTW_HOSTAPD_ACS) && (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 33)) */
 
+static int cfg80211_rtw_get_channel(struct wiphy *wiphy, struct wireless_dev *wdev, struct cfg80211_chan_def *chandef)
+{
+	_adapter *padapter = wiphy_to_adapter(wiphy);
+	struct dvobj_priv *dvobj = adapter_to_dvobj(padapter);
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
+	struct ieee80211_channel *chan;
+	enum nl80211_band band;
+	int ret = -ENODATA;
+	int freq;
+	u8 center_ch;
+
+	if (pmlmeext->cur_channel > 14)
+		band = NL80211_BAND_5GHZ;
+	else
+		band = NL80211_BAND_2GHZ;
+
+	freq = ieee80211_channel_to_frequency(pmlmeext->cur_channel, band);
+	chan = ieee80211_get_channel(wiphy, freq);
+
+	switch (pmlmeext->cur_bwmode) {
+	case CHANNEL_WIDTH_20:
+		chandef->width = NL80211_CHAN_WIDTH_20;
+		break;
+	case CHANNEL_WIDTH_40:
+		chandef->width = NL80211_CHAN_WIDTH_40;
+		break;
+	case CHANNEL_WIDTH_80:
+		chandef->width = NL80211_CHAN_WIDTH_80;
+		break;
+	case CHANNEL_WIDTH_80_80:
+		chandef->width = NL80211_CHAN_WIDTH_80P80;
+		break;
+	case CHANNEL_WIDTH_160:
+		chandef->width = NL80211_CHAN_WIDTH_160;
+		break;
+	default:
+		WARN_ON(1);
+		break;
+	}
+
+	center_ch = rtw_get_center_ch(pmlmeext->cur_channel, pmlmeext->cur_bwmode, pmlmeext->cur_ch_offset);
+	chandef->chan = chan;
+	chandef->center_freq1 = ieee80211_channel_to_frequency(center_ch, band);
+	chandef->center_freq2 = 0;
+
+	if (cfg80211_chandef_valid(chandef))
+		ret = 0;
+
+	#ifdef CONFIG_DEBUG_CFG80211
+	printk("%s: ret=%d, cur_channel=%d, cur_bwmode=%d, cur_ch_offset=%d, band=%d, center_ch=%d\n",
+		__func__, ret, pmlmeext->cur_channel, pmlmeext->cur_bwmode, pmlmeext->cur_ch_offset, band, center_ch);
+	#endif
+
+	return ret;
+}
+
 static struct cfg80211_ops rtw_cfg80211_ops = {
 	.change_virtual_intf = cfg80211_rtw_change_iface,
 	.add_key = cfg80211_rtw_add_key,
@@ -9677,6 +9734,7 @@ static struct cfg80211_ops rtw_cfg80211_
 #if defined(CONFIG_RTW_HOSTAPD_ACS) && (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 33))
 	.dump_survey = rtw_hostapd_acs_dump_survey,
 #endif
+	.get_channel = cfg80211_rtw_get_channel,
 };
 
 struct wiphy *rtw_wiphy_alloc(_adapter *padapter, struct device *dev)
Index: backports-2017-11-01/drivers/net/wireless/realtek/rtkwifiu/rtl8822cs/os_dep/linux/ioctl_cfg80211.c
===================================================================
--- backports-2017-11-01.orig/drivers/net/wireless/realtek/rtkwifiu/rtl8822cs/os_dep/linux/ioctl_cfg80211.c
+++ backports-2017-11-01/drivers/net/wireless/realtek/rtkwifiu/rtl8822cs/os_dep/linux/ioctl_cfg80211.c
@@ -4080,7 +4080,7 @@ static int cfg80211_rtw_get_txpower(stru
 #endif
 	int *dbm)
 {
-	RTW_INFO("%s\n", __func__);
+	RTW_DBG("%s\n", __func__);
 
 	*dbm = (12);
 
@@ -5635,7 +5635,7 @@ static int	cfg80211_rtw_dump_station(str
 	u8 asoc_list_num;
 
 	if (DBG_DUMP_STATION)
-		RTW_INFO(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
+		RTW_DBG(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
 
 	_enter_critical_bh(&pstapriv->asoc_list_lock, &irqL);
 	psta = rtw_sta_info_get_by_idx(pstapriv, idx, &asoc_list_num);
@@ -5656,7 +5656,7 @@ static int	cfg80211_rtw_dump_station(str
 		#endif
 	) {
 		if (DBG_DUMP_STATION)
-			RTW_INFO(FUNC_NDEV_FMT" end with idx:%d\n", FUNC_NDEV_ARG(ndev), idx);
+			RTW_DBG(FUNC_NDEV_FMT" end with idx:%d\n", FUNC_NDEV_ARG(ndev), idx);
 		ret = -ENOENT;
 		goto exit;
 	}
@@ -9368,7 +9368,7 @@ static void rtw_cfg80211_preinit_wiphy(_
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 2, 0))
 	/* wiphy->flags |= WIPHY_FLAG_SUPPORTS_FW_ROAM; */
 #endif
-
+	_rtw_memcpy(wiphy->perm_addr, adapter_mac_addr(adapter), ETH_ALEN);
 #ifdef CONFIG_RTW_MESH
 	wiphy->flags |= 0
 		#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37))
@@ -9560,6 +9560,63 @@ int rtw_hostapd_acs_dump_survey(struct w
 }
 #endif /* defined(CONFIG_RTW_HOSTAPD_ACS) && (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 33)) */
 
+static int cfg80211_rtw_get_channel(struct wiphy *wiphy, struct wireless_dev *wdev, struct cfg80211_chan_def *chandef)
+{
+	_adapter *padapter = wiphy_to_adapter(wiphy);
+	struct dvobj_priv *dvobj = adapter_to_dvobj(padapter);
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
+	struct ieee80211_channel *chan;
+	enum nl80211_band band;
+	int ret = -ENODATA;
+	int freq;
+	u8 center_ch;
+
+	if (pmlmeext->cur_channel > 14)
+		band = NL80211_BAND_5GHZ;
+	else
+		band = NL80211_BAND_2GHZ;
+
+	freq = ieee80211_channel_to_frequency(pmlmeext->cur_channel, band);
+	chan = ieee80211_get_channel(wiphy, freq);
+
+	switch (pmlmeext->cur_bwmode) {
+	case CHANNEL_WIDTH_20:
+		chandef->width = NL80211_CHAN_WIDTH_20;
+		break;
+	case CHANNEL_WIDTH_40:
+		chandef->width = NL80211_CHAN_WIDTH_40;
+		break;
+	case CHANNEL_WIDTH_80:
+		chandef->width = NL80211_CHAN_WIDTH_80;
+		break;
+	case CHANNEL_WIDTH_80_80:
+		chandef->width = NL80211_CHAN_WIDTH_80P80;
+		break;
+	case CHANNEL_WIDTH_160:
+		chandef->width = NL80211_CHAN_WIDTH_160;
+		break;
+	default:
+		WARN_ON(1);
+		break;
+	}
+
+	center_ch = rtw_get_center_ch(pmlmeext->cur_channel, pmlmeext->cur_bwmode, pmlmeext->cur_ch_offset);
+	chandef->chan = chan;
+	chandef->center_freq1 = ieee80211_channel_to_frequency(center_ch, band);
+	chandef->center_freq2 = 0;
+
+	if (cfg80211_chandef_valid(chandef))
+		ret = 0;
+
+	#ifdef CONFIG_DEBUG_CFG80211
+	printk("%s: ret=%d, cur_channel=%d, cur_bwmode=%d, cur_ch_offset=%d, band=%d, center_ch=%d\n",
+		__func__, ret, pmlmeext->cur_channel, pmlmeext->cur_bwmode, pmlmeext->cur_ch_offset, band, center_ch);
+	#endif
+
+	return ret;
+}
+
 static struct cfg80211_ops rtw_cfg80211_ops = {
 	.change_virtual_intf = cfg80211_rtw_change_iface,
 	.add_key = cfg80211_rtw_add_key,
@@ -9677,6 +9734,7 @@ static struct cfg80211_ops rtw_cfg80211_
 #if defined(CONFIG_RTW_HOSTAPD_ACS) && (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 33))
 	.dump_survey = rtw_hostapd_acs_dump_survey,
 #endif
+	.get_channel = cfg80211_rtw_get_channel,
 };
 
 struct wiphy *rtw_wiphy_alloc(_adapter *padapter, struct device *dev)
Index: backports-2017-11-01/drivers/net/wireless/realtek/rtkwifiu/rtl8822cu/os_dep/linux/ioctl_cfg80211.c
===================================================================
--- backports-2017-11-01.orig/drivers/net/wireless/realtek/rtkwifiu/rtl8822cu/os_dep/linux/ioctl_cfg80211.c
+++ backports-2017-11-01/drivers/net/wireless/realtek/rtkwifiu/rtl8822cu/os_dep/linux/ioctl_cfg80211.c
@@ -4080,7 +4080,7 @@ static int cfg80211_rtw_get_txpower(stru
 #endif
 	int *dbm)
 {
-	RTW_INFO("%s\n", __func__);
+	RTW_DBG("%s\n", __func__);
 
 	*dbm = (12);
 
@@ -5635,7 +5635,7 @@ static int	cfg80211_rtw_dump_station(str
 	u8 asoc_list_num;
 
 	if (DBG_DUMP_STATION)
-		RTW_INFO(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
+		RTW_DBG(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
 
 	_enter_critical_bh(&pstapriv->asoc_list_lock, &irqL);
 	psta = rtw_sta_info_get_by_idx(pstapriv, idx, &asoc_list_num);
@@ -5656,7 +5656,7 @@ static int	cfg80211_rtw_dump_station(str
 		#endif
 	) {
 		if (DBG_DUMP_STATION)
-			RTW_INFO(FUNC_NDEV_FMT" end with idx:%d\n", FUNC_NDEV_ARG(ndev), idx);
+			RTW_DBG(FUNC_NDEV_FMT" end with idx:%d\n", FUNC_NDEV_ARG(ndev), idx);
 		ret = -ENOENT;
 		goto exit;
 	}
@@ -9368,7 +9368,7 @@ static void rtw_cfg80211_preinit_wiphy(_
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 2, 0))
 	/* wiphy->flags |= WIPHY_FLAG_SUPPORTS_FW_ROAM; */
 #endif
-
+	_rtw_memcpy(wiphy->perm_addr, adapter_mac_addr(adapter), ETH_ALEN);
 #ifdef CONFIG_RTW_MESH
 	wiphy->flags |= 0
 		#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37))
@@ -9560,6 +9560,63 @@ int rtw_hostapd_acs_dump_survey(struct w
 }
 #endif /* defined(CONFIG_RTW_HOSTAPD_ACS) && (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 33)) */
 
+static int cfg80211_rtw_get_channel(struct wiphy *wiphy, struct wireless_dev *wdev, struct cfg80211_chan_def *chandef)
+{
+	_adapter *padapter = wiphy_to_adapter(wiphy);
+	struct dvobj_priv *dvobj = adapter_to_dvobj(padapter);
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
+	struct ieee80211_channel *chan;
+	enum nl80211_band band;
+	int ret = -ENODATA;
+	int freq;
+	u8 center_ch;
+
+	if (pmlmeext->cur_channel > 14)
+		band = NL80211_BAND_5GHZ;
+	else
+		band = NL80211_BAND_2GHZ;
+
+	freq = ieee80211_channel_to_frequency(pmlmeext->cur_channel, band);
+	chan = ieee80211_get_channel(wiphy, freq);
+
+	switch (pmlmeext->cur_bwmode) {
+	case CHANNEL_WIDTH_20:
+		chandef->width = NL80211_CHAN_WIDTH_20;
+		break;
+	case CHANNEL_WIDTH_40:
+		chandef->width = NL80211_CHAN_WIDTH_40;
+		break;
+	case CHANNEL_WIDTH_80:
+		chandef->width = NL80211_CHAN_WIDTH_80;
+		break;
+	case CHANNEL_WIDTH_80_80:
+		chandef->width = NL80211_CHAN_WIDTH_80P80;
+		break;
+	case CHANNEL_WIDTH_160:
+		chandef->width = NL80211_CHAN_WIDTH_160;
+		break;
+	default:
+		WARN_ON(1);
+		break;
+	}
+
+	center_ch = rtw_get_center_ch(pmlmeext->cur_channel, pmlmeext->cur_bwmode, pmlmeext->cur_ch_offset);
+	chandef->chan = chan;
+	chandef->center_freq1 = ieee80211_channel_to_frequency(center_ch, band);
+	chandef->center_freq2 = 0;
+
+	if (cfg80211_chandef_valid(chandef))
+		ret = 0;
+
+	#ifdef CONFIG_DEBUG_CFG80211
+	printk("%s: ret=%d, cur_channel=%d, cur_bwmode=%d, cur_ch_offset=%d, band=%d, center_ch=%d\n",
+		__func__, ret, pmlmeext->cur_channel, pmlmeext->cur_bwmode, pmlmeext->cur_ch_offset, band, center_ch);
+	#endif
+
+	return ret;
+}
+
 static struct cfg80211_ops rtw_cfg80211_ops = {
 	.change_virtual_intf = cfg80211_rtw_change_iface,
 	.add_key = cfg80211_rtw_add_key,
@@ -9677,6 +9734,7 @@ static struct cfg80211_ops rtw_cfg80211_
 #if defined(CONFIG_RTW_HOSTAPD_ACS) && (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 33))
 	.dump_survey = rtw_hostapd_acs_dump_survey,
 #endif
+	.get_channel = cfg80211_rtw_get_channel,
 };
 
 struct wiphy *rtw_wiphy_alloc(_adapter *padapter, struct device *dev)
Index: backports-2017-11-01/drivers/net/wireless/realtek/rtkwifiu/rtl8814ae/os_dep/linux/ioctl_cfg80211.c
===================================================================
--- backports-2017-11-01.orig/drivers/net/wireless/realtek/rtkwifiu/rtl8814ae/os_dep/linux/ioctl_cfg80211.c
+++ backports-2017-11-01/drivers/net/wireless/realtek/rtkwifiu/rtl8814ae/os_dep/linux/ioctl_cfg80211.c
@@ -3195,7 +3195,7 @@ static int cfg80211_rtw_get_txpower(stru
 #endif
 	int *dbm)
 {
-	RTW_INFO("%s\n", __func__);
+	RTW_DBG("%s\n", __func__);
 
 	*dbm = (12);
 
@@ -4217,13 +4217,13 @@ static int	cfg80211_rtw_dump_station(str
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(ndev);
 	struct sta_info *psta = NULL;
 	struct sta_priv *pstapriv = &padapter->stapriv;
-	RTW_INFO(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
+	RTW_DBG(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
 
 	_enter_critical_bh(&pstapriv->asoc_list_lock, &irqL);
 	psta = rtw_sta_info_get_by_idx(idx, pstapriv);
 	_exit_critical_bh(&pstapriv->asoc_list_lock, &irqL);
 	if (NULL == psta) {
-		RTW_INFO("Station is not found\n");
+		RTW_DBG("Station is not found\n");
 		ret = -ENOENT;
 		goto exit;
 	}
@@ -5607,6 +5607,173 @@ static int cfg80211_rtw_sched_scan_stop(
 	return rtw_android_pno_enable(dev, _FALSE);
 }
 #endif /* CONFIG_PNO_SUPPORT */
+#ifdef CONFIG_FIND_BEST_CHANNEL
+static int get_best_channel(_adapter *padapter, enum nl80211_band band)
+{
+	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
+	u32 i, best_channel_24G = 1, best_channel_5G = 36, index_24G = 0, index_5G = 0;
+
+	for (i=0; pmlmeext->channel_set[i].ChannelNum !=0; i++) {
+		if ( pmlmeext->channel_set[i].ChannelNum == 1)
+			index_24G = i;
+		if ( pmlmeext->channel_set[i].ChannelNum == 36)
+			index_5G = i;
+	}
+
+	for (i=0; (i < MAX_CHANNEL_NUM) && (pmlmeext->channel_set[i].ChannelNum !=0) ; i++) {
+		if (pmlmeext->channel_set[i].ScanType == SCAN_PASSIVE)
+			continue;
+		// 2.4G
+		if ( pmlmeext->channel_set[i].ChannelNum == 6 || pmlmeext->channel_set[i].ChannelNum == 11) {
+			if ( pmlmeext->channel_set[i].rx_count < pmlmeext->channel_set[index_24G].rx_count ) {
+				index_24G = i;
+				best_channel_24G = pmlmeext->channel_set[i].ChannelNum;
+			}
+		}
+
+		// 5G
+		if ( pmlmeext->channel_set[i].ChannelNum >= 36
+			&& pmlmeext->channel_set[i].ChannelNum < 140 ) {
+			// Find primary channel
+			if ( (( pmlmeext->channel_set[i].ChannelNum - 36) % 8 == 0)
+				&& (pmlmeext->channel_set[i].rx_count < pmlmeext->channel_set[index_5G].rx_count) ) {
+				index_5G = i;
+				best_channel_5G = pmlmeext->channel_set[i].ChannelNum;
+			}
+		}
+
+		if ( pmlmeext->channel_set[i].ChannelNum >= 149
+			&& pmlmeext->channel_set[i].ChannelNum < 165) {
+			// find primary channel
+			if ( (( pmlmeext->channel_set[i].ChannelNum - 149) % 8 == 0)
+				&& (pmlmeext->channel_set[i].rx_count < pmlmeext->channel_set[index_5G].rx_count) ) {
+				index_5G = i;
+				best_channel_5G = pmlmeext->channel_set[i].ChannelNum;
+			}
+		}
+	}
+
+	if (band == NL80211_BAND_2GHZ)
+		return best_channel_24G;
+
+	return best_channel_5G;
+}
+#endif
+
+static int cfg80211_rtw_dump_survey(struct wiphy *wiphy, struct net_device *dev, int idx, struct survey_info *survey)
+{
+	_adapter *padapter = wiphy_to_adapter(wiphy);
+	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
+	struct ss_res *ss = &pmlmeext->sitesurvey_res;
+	struct rtw_ieee80211_channel *ch;
+	struct ieee80211_supported_band *sband=NULL;
+	int freq, band=0;
+	int best_ch = -1;
+
+	if (idx >= ss->ch_num)
+		return -EINVAL;
+
+	ch = &ss->ch[idx];
+
+	if (!ch)
+		return -EINVAL;
+
+	if (ch->hw_value > 14)
+		band = NL80211_BAND_5GHZ;
+	else
+		band = NL80211_BAND_2GHZ;
+
+	sband = wiphy->bands[band];
+
+	if(!sband) {
+		printk("%s under unknown band!!\n",dev->name);
+		return -EINVAL;
+	}
+
+	if(sband->band == NL80211_BAND_2GHZ)
+		freq = ieee80211_channel_to_frequency(ch->hw_value, NL80211_BAND_2GHZ);
+	else
+		freq = ieee80211_channel_to_frequency(ch->hw_value, NL80211_BAND_5GHZ);
+
+	survey->channel = ieee80211_get_channel(wiphy, freq);
+	#ifdef CONFIG_FIND_BEST_CHANNEL
+	best_ch = get_best_channel(padapter, sband->band);
+	#endif
+
+	if (best_ch == ch->hw_value)
+		survey->noise = -100;
+	else
+		survey->noise = -50;
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4,0,0))
+	survey->time = 100;
+	survey->time_busy = 50;
+	survey->filled = SURVEY_INFO_NOISE_DBM | SURVEY_INFO_TIME | SURVEY_INFO_TIME_BUSY;
+#else
+	survey->channel_time = 100;
+	survey->channel_time_busy = 50
+	survey->filled = SURVEY_INFO_NOISE_DBM | SURVEY_INFO_CHANNEL_TIME | SURVEY_INFO_CHANNEL_TIME_BUSY;
+#endif
+
+	return 0;
+}
+
+static int cfg80211_rtw_get_channel(struct wiphy *wiphy, struct wireless_dev *wdev, struct cfg80211_chan_def *chandef)
+{
+	_adapter *padapter = wiphy_to_adapter(wiphy);
+	struct dvobj_priv *dvobj = adapter_to_dvobj(padapter);
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
+	struct ieee80211_channel *chan;
+	enum nl80211_band band;
+	int ret = -ENODATA;
+	int freq;
+	u8 center_ch;
+
+	if (pmlmeext->cur_channel > 14)
+		band = NL80211_BAND_5GHZ;
+	else
+		band = NL80211_BAND_2GHZ;
+
+	freq = ieee80211_channel_to_frequency(pmlmeext->cur_channel, band);
+	chan = ieee80211_get_channel(wiphy, freq);
+
+	switch (pmlmeext->cur_bwmode) {
+	case CHANNEL_WIDTH_20:
+		chandef->width = NL80211_CHAN_WIDTH_20;
+		break;
+	case CHANNEL_WIDTH_40:
+		chandef->width = NL80211_CHAN_WIDTH_40;
+		break;
+	case CHANNEL_WIDTH_80:
+		chandef->width = NL80211_CHAN_WIDTH_80;
+		break;
+	case CHANNEL_WIDTH_80_80:
+		chandef->width = NL80211_CHAN_WIDTH_80P80;
+		break;
+	case CHANNEL_WIDTH_160:
+		chandef->width = NL80211_CHAN_WIDTH_160;
+		break;
+	default:
+		WARN_ON(1);
+		break;
+	}
+
+	center_ch = rtw_get_center_ch(pmlmeext->cur_channel, pmlmeext->cur_bwmode, pmlmeext->cur_ch_offset);
+	chandef->chan = chan;
+	chandef->center_freq1 = ieee80211_channel_to_frequency(center_ch, band);
+	chandef->center_freq2 = 0;
+
+	if (cfg80211_chandef_valid(chandef))
+		ret = 0;
+
+	#ifdef CONFIG_DEBUG_CFG80211
+	printk("%s: ret=%d, cur_channel=%d, cur_bwmode=%d, cur_ch_offset=%d, band=%d, center_ch=%d\n",
+		__func__, ret, pmlmeext->cur_channel, pmlmeext->cur_bwmode, pmlmeext->cur_ch_offset, band, center_ch);
+	#endif
+
+	return ret;
+}
 
 static int rtw_cfg80211_set_beacon_wpsp2pie(struct net_device *ndev, char *buf, int len)
 {
@@ -6280,6 +6447,7 @@ static void rtw_cfg80211_preinit_wiphy(_
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 2, 0))
 	/* wiphy->flags |= WIPHY_FLAG_SUPPORTS_FW_ROAM; */
 #endif
+	_rtw_memcpy(wiphy->perm_addr, adapter_mac_addr(adapter), ETH_ALEN);
 }
 
 static struct cfg80211_ops rtw_cfg80211_ops = {
@@ -6362,6 +6530,8 @@ static struct cfg80211_ops rtw_cfg80211_
 	.sched_scan_start = cfg80211_rtw_sched_scan_start,
 	.sched_scan_stop = cfg80211_rtw_sched_scan_stop,
 #endif /* CONFIG_PNO_SUPPORT */
+	.dump_survey = cfg80211_rtw_dump_survey,
+	.get_channel = cfg80211_rtw_get_channel,
 };
 
 struct wiphy *rtw_wiphy_alloc(_adapter *padapter, struct device *dev)
Index: backports-2017-11-01/drivers/net/wireless/realtek/rtkwifiu/rtl8821as/os_dep/linux/ioctl_cfg80211.c
===================================================================
--- backports-2017-11-01.orig/drivers/net/wireless/realtek/rtkwifiu/rtl8821as/os_dep/linux/ioctl_cfg80211.c
+++ backports-2017-11-01/drivers/net/wireless/realtek/rtkwifiu/rtl8821as/os_dep/linux/ioctl_cfg80211.c
@@ -3525,7 +3525,7 @@ static int cfg80211_rtw_get_txpower(stru
 #endif
 	int *dbm)
 {
-	DBG_8192C("%s\n", __func__);
+	/* DBG_8192C("%s\n", __func__); */
 
 	*dbm = (12);
 	
@@ -4535,14 +4535,14 @@ static int	cfg80211_rtw_dump_station(str
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(ndev);
 	struct sta_info *psta = NULL;
 	struct sta_priv *pstapriv = &padapter->stapriv;
-	DBG_871X(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
+	/* DBG_871X(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev)); */
 
 	_enter_critical_bh(&pstapriv->asoc_list_lock, &irqL);
 	psta = rtw_sta_info_get_by_idx(idx, pstapriv);
 	_exit_critical_bh(&pstapriv->asoc_list_lock, &irqL);
 	if(NULL == psta)
 	{
-		DBG_871X("Station is not found\n");
+		/* DBG_871X("Station is not found\n"); */
 		ret = -ENOENT;
 		goto exit;
 	}
@@ -5871,6 +5871,174 @@ static int cfg80211_rtw_sched_scan_stop(
 }
 #endif /* CONFIG_PNO_SUPPORT */
 
+#ifdef CONFIG_FIND_BEST_CHANNEL
+static int get_best_channel(_adapter *padapter, enum nl80211_band band)
+{
+	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
+	u32 i, best_channel_24G = 1, best_channel_5G = 36, index_24G = 0, index_5G = 0;
+
+	for (i=0; pmlmeext->channel_set[i].ChannelNum !=0; i++) {
+		if ( pmlmeext->channel_set[i].ChannelNum == 1)
+			index_24G = i;
+		if ( pmlmeext->channel_set[i].ChannelNum == 36)
+			index_5G = i;
+	}
+
+	for (i=0; (i < MAX_CHANNEL_NUM) && (pmlmeext->channel_set[i].ChannelNum !=0) ; i++) {
+		if (pmlmeext->channel_set[i].ScanType == SCAN_PASSIVE)
+			continue;
+		// 2.4G
+		if ( pmlmeext->channel_set[i].ChannelNum == 6 || pmlmeext->channel_set[i].ChannelNum == 11) {
+			if ( pmlmeext->channel_set[i].rx_count < pmlmeext->channel_set[index_24G].rx_count ) {
+				index_24G = i;
+				best_channel_24G = pmlmeext->channel_set[i].ChannelNum;
+			}
+		}
+
+		// 5G
+		if ( pmlmeext->channel_set[i].ChannelNum >= 36
+			&& pmlmeext->channel_set[i].ChannelNum < 140 ) {
+			// Find primary channel
+			if ( (( pmlmeext->channel_set[i].ChannelNum - 36) % 8 == 0)
+				&& (pmlmeext->channel_set[i].rx_count < pmlmeext->channel_set[index_5G].rx_count) ) {
+				index_5G = i;
+				best_channel_5G = pmlmeext->channel_set[i].ChannelNum;
+			}
+		}
+
+		if ( pmlmeext->channel_set[i].ChannelNum >= 149
+			&& pmlmeext->channel_set[i].ChannelNum < 165) {
+			// find primary channel
+			if ( (( pmlmeext->channel_set[i].ChannelNum - 149) % 8 == 0)
+				&& (pmlmeext->channel_set[i].rx_count < pmlmeext->channel_set[index_5G].rx_count) ) {
+				index_5G = i;
+				best_channel_5G = pmlmeext->channel_set[i].ChannelNum;
+			}
+		}
+	}
+
+	if (band == NL80211_BAND_2GHZ)
+		return best_channel_24G;
+
+	return best_channel_5G;
+}
+#endif
+
+static int cfg80211_rtw_dump_survey(struct wiphy *wiphy, struct net_device *dev, int idx, struct survey_info *survey)
+{
+	_adapter *padapter = wiphy_to_adapter(wiphy);
+	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
+	struct ss_res *ss = &pmlmeext->sitesurvey_res;
+	struct rtw_ieee80211_channel *ch;
+	struct ieee80211_supported_band *sband=NULL;
+	int freq, band=0;
+	int best_ch = -1;
+
+	if (idx >= ss->ch_num)
+		return -EINVAL;
+
+	ch = &ss->ch[idx];
+
+	if (!ch)
+		return -EINVAL;
+
+	if (ch->hw_value > 14)
+		band = NL80211_BAND_5GHZ;
+	else
+		band = NL80211_BAND_2GHZ;
+
+	sband = wiphy->bands[band];
+
+	if(!sband) {
+		printk("%s under unknown band!!\n",dev->name);
+		return -EINVAL;
+	}
+
+	if(sband->band == NL80211_BAND_2GHZ)
+		freq = ieee80211_channel_to_frequency(ch->hw_value, NL80211_BAND_2GHZ);
+	else
+		freq = ieee80211_channel_to_frequency(ch->hw_value, NL80211_BAND_5GHZ);
+
+	survey->channel = ieee80211_get_channel(wiphy, freq);
+	#ifdef CONFIG_FIND_BEST_CHANNEL
+	best_ch = get_best_channel(padapter, sband->band);
+	#endif
+
+	if (best_ch == ch->hw_value)
+		survey->noise = -100;
+	else
+		survey->noise = -50;
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4,0,0))
+	survey->time = 100;
+	survey->time_busy = 50;
+	survey->filled = SURVEY_INFO_NOISE_DBM | SURVEY_INFO_TIME | SURVEY_INFO_TIME_BUSY;
+#else
+	survey->channel_time = 100;
+	survey->channel_time_busy = 50
+	survey->filled = SURVEY_INFO_NOISE_DBM | SURVEY_INFO_CHANNEL_TIME | SURVEY_INFO_CHANNEL_TIME_BUSY;
+#endif
+
+	return 0;
+}
+
+static int cfg80211_rtw_get_channel(struct wiphy *wiphy, struct wireless_dev *wdev, struct cfg80211_chan_def *chandef)
+{
+	_adapter *padapter = wiphy_to_adapter(wiphy);
+	struct dvobj_priv *dvobj = adapter_to_dvobj(padapter);
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
+	struct ieee80211_channel *chan;
+	enum nl80211_band band;
+	int ret = -ENODATA;
+	int freq;
+	u8 center_ch;
+
+	if (pmlmeext->cur_channel > 14)
+		band = NL80211_BAND_5GHZ;
+	else
+		band = NL80211_BAND_2GHZ;
+
+	freq = ieee80211_channel_to_frequency(pmlmeext->cur_channel, band);
+	chan = ieee80211_get_channel(wiphy, freq);
+
+	switch (pmlmeext->cur_bwmode) {
+	case CHANNEL_WIDTH_20:
+		chandef->width = NL80211_CHAN_WIDTH_20;
+		break;
+	case CHANNEL_WIDTH_40:
+		chandef->width = NL80211_CHAN_WIDTH_40;
+		break;
+	case CHANNEL_WIDTH_80:
+		chandef->width = NL80211_CHAN_WIDTH_80;
+		break;
+	case CHANNEL_WIDTH_80_80:
+		chandef->width = NL80211_CHAN_WIDTH_80P80;
+		break;
+	case CHANNEL_WIDTH_160:
+		chandef->width = NL80211_CHAN_WIDTH_160;
+		break;
+	default:
+		WARN_ON(1);
+		break;
+	}
+
+	center_ch = rtw_get_center_ch(pmlmeext->cur_channel, pmlmeext->cur_bwmode, pmlmeext->cur_ch_offset);
+	chandef->chan = chan;
+	chandef->center_freq1 = ieee80211_channel_to_frequency(center_ch, band);
+	chandef->center_freq2 = 0;
+
+	if (cfg80211_chandef_valid(chandef))
+		ret = 0;
+
+	#ifdef CONFIG_DEBUG_CFG80211
+	printk("%s: ret=%d, cur_channel=%d, cur_bwmode=%d, cur_ch_offset=%d, band=%d, center_ch=%d\n",
+		__func__, ret, pmlmeext->cur_channel, pmlmeext->cur_bwmode, pmlmeext->cur_ch_offset, band, center_ch);
+	#endif
+
+	return ret;
+}
+
 static int rtw_cfg80211_set_beacon_wpsp2pie(struct net_device *ndev, char *buf, int len)
 {	
 	int ret = 0;
@@ -6539,6 +6707,7 @@ static void rtw_cfg80211_preinit_wiphy(_
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,2,0))
 	//wiphy->flags |= WIPHY_FLAG_SUPPORTS_FW_ROAM;
 #endif
+	_rtw_memcpy(wiphy->perm_addr, adapter_mac_addr(adapter), ETH_ALEN);
 }
 
 static struct cfg80211_ops rtw_cfg80211_ops = {
@@ -6613,6 +6782,8 @@ static struct cfg80211_ops rtw_cfg80211_
 	.sched_scan_start = cfg80211_rtw_sched_scan_start,
 	.sched_scan_stop = cfg80211_rtw_sched_scan_stop,
 #endif /* CONFIG_PNO_SUPPORT */
+	.dump_survey = cfg80211_rtw_dump_survey,
+	.get_channel = cfg80211_rtw_get_channel,
 };
 
 struct wiphy *rtw_wiphy_alloc(_adapter *padapter, struct device *dev)
Index: backports-2017-11-01/drivers/net/wireless/realtek/rtkwifiu/rtl8821au/os_dep/linux/ioctl_cfg80211.c
===================================================================
--- backports-2017-11-01.orig/drivers/net/wireless/realtek/rtkwifiu/rtl8821au/os_dep/linux/ioctl_cfg80211.c
+++ backports-2017-11-01/drivers/net/wireless/realtek/rtkwifiu/rtl8821au/os_dep/linux/ioctl_cfg80211.c
@@ -3490,7 +3490,7 @@ static int cfg80211_rtw_get_txpower(stru
 #endif
 	int *dbm)
 {
-	DBG_8192C("%s\n", __func__);
+	/* DBG_8192C("%s\n", __func__); */
 
 	*dbm = (12);
 	
@@ -4513,14 +4513,14 @@ static int	cfg80211_rtw_dump_station(str
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(ndev);
 	struct sta_info *psta = NULL;
 	struct sta_priv *pstapriv = &padapter->stapriv;
-	DBG_871X(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
+	/* DBG_871X(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev)); */
 
 	_enter_critical_bh(&pstapriv->asoc_list_lock, &irqL);
 	psta = rtw_sta_info_get_by_idx(idx, pstapriv);
 	_exit_critical_bh(&pstapriv->asoc_list_lock, &irqL);
 	if(NULL == psta)
 	{
-		DBG_871X("Station is not found\n");
+		/* DBG_871X("Station is not found\n"); */
 		ret = -ENOENT;
 		goto exit;
 	}
@@ -5850,6 +5850,174 @@ static int cfg80211_rtw_sched_scan_stop(
 }
 #endif /* CONFIG_PNO_SUPPORT */
 
+#ifdef CONFIG_FIND_BEST_CHANNEL
+static int get_best_channel(_adapter *padapter, enum nl80211_band band)
+{
+	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
+	u32 i, best_channel_24G = 1, best_channel_5G = 36, index_24G = 0, index_5G = 0;
+
+	for (i=0; pmlmeext->channel_set[i].ChannelNum !=0; i++) {
+		if ( pmlmeext->channel_set[i].ChannelNum == 1)
+			index_24G = i;
+		if ( pmlmeext->channel_set[i].ChannelNum == 36)
+			index_5G = i;
+	}
+
+	for (i=0; (i < MAX_CHANNEL_NUM) && (pmlmeext->channel_set[i].ChannelNum !=0) ; i++) {
+		if (pmlmeext->channel_set[i].ScanType == SCAN_PASSIVE)
+			continue;
+		// 2.4G
+		if ( pmlmeext->channel_set[i].ChannelNum == 6 || pmlmeext->channel_set[i].ChannelNum == 11) {
+			if ( pmlmeext->channel_set[i].rx_count < pmlmeext->channel_set[index_24G].rx_count ) {
+				index_24G = i;
+				best_channel_24G = pmlmeext->channel_set[i].ChannelNum;
+			}
+		}
+
+		// 5G
+		if ( pmlmeext->channel_set[i].ChannelNum >= 36
+			&& pmlmeext->channel_set[i].ChannelNum < 140 ) {
+			// Find primary channel
+			if ( (( pmlmeext->channel_set[i].ChannelNum - 36) % 8 == 0)
+				&& (pmlmeext->channel_set[i].rx_count < pmlmeext->channel_set[index_5G].rx_count) ) {
+				index_5G = i;
+				best_channel_5G = pmlmeext->channel_set[i].ChannelNum;
+			}
+		}
+
+		if ( pmlmeext->channel_set[i].ChannelNum >= 149
+			&& pmlmeext->channel_set[i].ChannelNum < 165) {
+			// find primary channel
+			if ( (( pmlmeext->channel_set[i].ChannelNum - 149) % 8 == 0)
+				&& (pmlmeext->channel_set[i].rx_count < pmlmeext->channel_set[index_5G].rx_count) ) {
+				index_5G = i;
+				best_channel_5G = pmlmeext->channel_set[i].ChannelNum;
+			}
+		}
+	}
+
+	if (band == NL80211_BAND_2GHZ)
+		return best_channel_24G;
+
+	return best_channel_5G;
+}
+#endif
+
+static int cfg80211_rtw_dump_survey(struct wiphy *wiphy, struct net_device *dev, int idx, struct survey_info *survey)
+{
+	_adapter *padapter = wiphy_to_adapter(wiphy);
+	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
+	struct ss_res *ss = &pmlmeext->sitesurvey_res;
+	struct rtw_ieee80211_channel *ch;
+	struct ieee80211_supported_band *sband=NULL;
+	int freq, band=0;
+	int best_ch = -1;
+
+	if (idx >= ss->ch_num)
+		return -EINVAL;
+
+	ch = &ss->ch[idx];
+
+	if (!ch)
+		return -EINVAL;
+
+	if (ch->hw_value > 14)
+		band = NL80211_BAND_5GHZ;
+	else
+		band = NL80211_BAND_2GHZ;
+
+	sband = wiphy->bands[band];
+
+	if(!sband) {
+		printk("%s under unknown band!!\n",dev->name);
+		return -EINVAL;
+	}
+
+	if(sband->band == NL80211_BAND_2GHZ)
+		freq = ieee80211_channel_to_frequency(ch->hw_value, NL80211_BAND_2GHZ);
+	else
+		freq = ieee80211_channel_to_frequency(ch->hw_value, NL80211_BAND_5GHZ);
+
+	survey->channel = ieee80211_get_channel(wiphy, freq);
+	#ifdef CONFIG_FIND_BEST_CHANNEL
+	best_ch = get_best_channel(padapter, sband->band);
+	#endif
+
+	if (best_ch == ch->hw_value)
+		survey->noise = -100;
+	else
+		survey->noise = -50;
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4,0,0))
+	survey->time = 100;
+	survey->time_busy = 50;
+	survey->filled = SURVEY_INFO_NOISE_DBM | SURVEY_INFO_TIME | SURVEY_INFO_TIME_BUSY;
+#else
+	survey->channel_time = 100;
+	survey->channel_time_busy = 50
+	survey->filled = SURVEY_INFO_NOISE_DBM | SURVEY_INFO_CHANNEL_TIME | SURVEY_INFO_CHANNEL_TIME_BUSY;
+#endif
+
+	return 0;
+}
+
+static int cfg80211_rtw_get_channel(struct wiphy *wiphy, struct wireless_dev *wdev, struct cfg80211_chan_def *chandef)
+{
+	_adapter *padapter = wiphy_to_adapter(wiphy);
+	struct dvobj_priv *dvobj = adapter_to_dvobj(padapter);
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
+	struct ieee80211_channel *chan;
+	enum nl80211_band band;
+	int ret = -ENODATA;
+	int freq;
+	u8 center_ch;
+
+	if (pmlmeext->cur_channel > 14)
+		band = NL80211_BAND_5GHZ;
+	else
+		band = NL80211_BAND_2GHZ;
+
+	freq = ieee80211_channel_to_frequency(pmlmeext->cur_channel, band);
+	chan = ieee80211_get_channel(wiphy, freq);
+
+	switch (pmlmeext->cur_bwmode) {
+	case CHANNEL_WIDTH_20:
+		chandef->width = NL80211_CHAN_WIDTH_20;
+		break;
+	case CHANNEL_WIDTH_40:
+		chandef->width = NL80211_CHAN_WIDTH_40;
+		break;
+	case CHANNEL_WIDTH_80:
+		chandef->width = NL80211_CHAN_WIDTH_80;
+		break;
+	case CHANNEL_WIDTH_80_80:
+		chandef->width = NL80211_CHAN_WIDTH_80P80;
+		break;
+	case CHANNEL_WIDTH_160:
+		chandef->width = NL80211_CHAN_WIDTH_160;
+		break;
+	default:
+		WARN_ON(1);
+		break;
+	}
+
+	center_ch = rtw_get_center_ch(pmlmeext->cur_channel, pmlmeext->cur_bwmode, pmlmeext->cur_ch_offset);
+	chandef->chan = chan;
+	chandef->center_freq1 = ieee80211_channel_to_frequency(center_ch, band);
+	chandef->center_freq2 = 0;
+
+	if (cfg80211_chandef_valid(chandef))
+		ret = 0;
+
+	#ifdef CONFIG_DEBUG_CFG80211
+	printk("%s: ret=%d, cur_channel=%d, cur_bwmode=%d, cur_ch_offset=%d, band=%d, center_ch=%d\n",
+		__func__, ret, pmlmeext->cur_channel, pmlmeext->cur_bwmode, pmlmeext->cur_ch_offset, band, center_ch);
+	#endif
+
+	return ret;
+}
+
 static int rtw_cfg80211_set_beacon_wpsp2pie(struct net_device *ndev, char *buf, int len)
 {	
 	int ret = 0;
@@ -6518,6 +6686,7 @@ static void rtw_cfg80211_preinit_wiphy(_
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,2,0))
 	//wiphy->flags |= WIPHY_FLAG_SUPPORTS_FW_ROAM;
 #endif
+	_rtw_memcpy(wiphy->perm_addr, adapter_mac_addr(adapter), ETH_ALEN);
 }
 
 static struct cfg80211_ops rtw_cfg80211_ops = {
@@ -6592,6 +6761,8 @@ static struct cfg80211_ops rtw_cfg80211_
 	.sched_scan_start = cfg80211_rtw_sched_scan_start,
 	.sched_scan_stop = cfg80211_rtw_sched_scan_stop,
 #endif /* CONFIG_PNO_SUPPORT */
+	.dump_survey = cfg80211_rtw_dump_survey,
+	.get_channel = cfg80211_rtw_get_channel,
 };
 
 struct wiphy *rtw_wiphy_alloc(_adapter *padapter, struct device *dev)
Index: backports-2017-11-01/drivers/net/wireless/realtek/rtkwifiu/rtl8723de/os_dep/linux/ioctl_cfg80211.c
===================================================================
--- backports-2017-11-01.orig/drivers/net/wireless/realtek/rtkwifiu/rtl8723de/os_dep/linux/ioctl_cfg80211.c
+++ backports-2017-11-01/drivers/net/wireless/realtek/rtkwifiu/rtl8723de/os_dep/linux/ioctl_cfg80211.c
@@ -4080,7 +4080,7 @@ static int cfg80211_rtw_get_txpower(stru
 #endif
 	int *dbm)
 {
-	RTW_INFO("%s\n", __func__);
+	RTW_DBG("%s\n", __func__);
 
 	*dbm = (12);
 
@@ -5635,7 +5635,7 @@ static int	cfg80211_rtw_dump_station(str
 	u8 asoc_list_num;
 
 	if (DBG_DUMP_STATION)
-		RTW_INFO(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
+		RTW_DBG(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
 
 	_enter_critical_bh(&pstapriv->asoc_list_lock, &irqL);
 	psta = rtw_sta_info_get_by_idx(pstapriv, idx, &asoc_list_num);
@@ -5656,7 +5656,7 @@ static int	cfg80211_rtw_dump_station(str
 		#endif
 	) {
 		if (DBG_DUMP_STATION)
-			RTW_INFO(FUNC_NDEV_FMT" end with idx:%d\n", FUNC_NDEV_ARG(ndev), idx);
+			RTW_DBG(FUNC_NDEV_FMT" end with idx:%d\n", FUNC_NDEV_ARG(ndev), idx);
 		ret = -ENOENT;
 		goto exit;
 	}
@@ -9387,6 +9387,7 @@ static void rtw_cfg80211_preinit_wiphy(_
 		;
 #endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 3, 0)) */
 #endif /* CONFIG_RTW_MESH */
+	_rtw_memcpy(wiphy->perm_addr, adapter_mac_addr(adapter), ETH_ALEN);
 }
 
 #ifdef CONFIG_RFKILL_POLL
@@ -9560,6 +9561,63 @@ int rtw_hostapd_acs_dump_survey(struct w
 }
 #endif /* defined(CONFIG_RTW_HOSTAPD_ACS) && (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 33)) */
 
+static int cfg80211_rtw_get_channel(struct wiphy *wiphy, struct wireless_dev *wdev, struct cfg80211_chan_def *chandef)
+{
+	_adapter *padapter = wiphy_to_adapter(wiphy);
+	struct dvobj_priv *dvobj = adapter_to_dvobj(padapter);
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
+	struct ieee80211_channel *chan;
+	enum nl80211_band band;
+	int ret = -ENODATA;
+	int freq;
+	u8 center_ch;
+
+	if (pmlmeext->cur_channel > 14)
+		band = NL80211_BAND_5GHZ;
+	else
+		band = NL80211_BAND_2GHZ;
+
+	freq = ieee80211_channel_to_frequency(pmlmeext->cur_channel, band);
+	chan = ieee80211_get_channel(wiphy, freq);
+
+	switch (pmlmeext->cur_bwmode) {
+	case CHANNEL_WIDTH_20:
+		chandef->width = NL80211_CHAN_WIDTH_20;
+		break;
+	case CHANNEL_WIDTH_40:
+		chandef->width = NL80211_CHAN_WIDTH_40;
+		break;
+	case CHANNEL_WIDTH_80:
+		chandef->width = NL80211_CHAN_WIDTH_80;
+		break;
+	case CHANNEL_WIDTH_80_80:
+		chandef->width = NL80211_CHAN_WIDTH_80P80;
+		break;
+	case CHANNEL_WIDTH_160:
+		chandef->width = NL80211_CHAN_WIDTH_160;
+		break;
+	default:
+		WARN_ON(1);
+		break;
+	}
+
+	center_ch = rtw_get_center_ch(pmlmeext->cur_channel, pmlmeext->cur_bwmode, pmlmeext->cur_ch_offset);
+	chandef->chan = chan;
+	chandef->center_freq1 = ieee80211_channel_to_frequency(center_ch, band);
+	chandef->center_freq2 = 0;
+
+	if (cfg80211_chandef_valid(chandef))
+		ret = 0;
+
+	#ifdef CONFIG_DEBUG_CFG80211
+	printk("%s: ret=%d, cur_channel=%d, cur_bwmode=%d, cur_ch_offset=%d, band=%d, center_ch=%d\n",
+		__func__, ret, pmlmeext->cur_channel, pmlmeext->cur_bwmode, pmlmeext->cur_ch_offset, band, center_ch);
+	#endif
+
+	return ret;
+}
+
 static struct cfg80211_ops rtw_cfg80211_ops = {
 	.change_virtual_intf = cfg80211_rtw_change_iface,
 	.add_key = cfg80211_rtw_add_key,
@@ -9677,6 +9735,7 @@ static struct cfg80211_ops rtw_cfg80211_
 #if defined(CONFIG_RTW_HOSTAPD_ACS) && (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 33))
 	.dump_survey = rtw_hostapd_acs_dump_survey,
 #endif
+	.get_channel = cfg80211_rtw_get_channel,
 };
 
 struct wiphy *rtw_wiphy_alloc(_adapter *padapter, struct device *dev)
Index: backports-2017-11-01/drivers/net/wireless/realtek/rtkwifiu/rtl8192eu/os_dep/linux/ioctl_cfg80211.c
===================================================================
--- backports-2017-11-01.orig/drivers/net/wireless/realtek/rtkwifiu/rtl8192eu/os_dep/linux/ioctl_cfg80211.c
+++ backports-2017-11-01/drivers/net/wireless/realtek/rtkwifiu/rtl8192eu/os_dep/linux/ioctl_cfg80211.c
@@ -3616,7 +3616,7 @@ static int cfg80211_rtw_get_txpower(stru
 #endif
 	int *dbm)
 {
-	RTW_INFO("%s\n", __func__);
+	RTW_DBG("%s\n", __func__);
 
 	*dbm = (12);
 
@@ -4683,13 +4683,13 @@ static int	cfg80211_rtw_dump_station(str
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(ndev);
 	struct sta_info *psta = NULL;
 	struct sta_priv *pstapriv = &padapter->stapriv;
-	RTW_INFO(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
+	RTW_DBG(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
 
 	_enter_critical_bh(&pstapriv->asoc_list_lock, &irqL);
 	psta = rtw_sta_info_get_by_idx(idx, pstapriv);
 	_exit_critical_bh(&pstapriv->asoc_list_lock, &irqL);
 	if (NULL == psta) {
-		RTW_INFO("Station is not found\n");
+		RTW_DBG("Station is not found\n");
 		ret = -ENOENT;
 		goto exit;
 	}
@@ -7142,6 +7142,7 @@ static void rtw_cfg80211_preinit_wiphy(_
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 2, 0))
 	/* wiphy->flags |= WIPHY_FLAG_SUPPORTS_FW_ROAM; */
 #endif
+	 _rtw_memcpy(wiphy->perm_addr, adapter_mac_addr(adapter), ETH_ALEN);
 }
 
 #ifdef CONFIG_RFKILL_POLL
@@ -7315,6 +7316,63 @@ int rtw_hostapd_acs_dump_survey(struct w
 }
 #endif /* defined(CONFIG_RTW_HOSTAPD_ACS) && (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 33)) */
 
+static int cfg80211_rtw_get_channel(struct wiphy *wiphy, struct wireless_dev *wdev, struct cfg80211_chan_def *chandef)
+{
+	_adapter *padapter = wiphy_to_adapter(wiphy);
+	struct dvobj_priv *dvobj = adapter_to_dvobj(padapter);
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
+	struct ieee80211_channel *chan;
+	enum nl80211_band band;
+	int ret = -ENODATA;
+	int freq;
+	u8 center_ch;
+
+	if (pmlmeext->cur_channel > 14)
+		band = NL80211_BAND_5GHZ;
+	else
+		band = NL80211_BAND_2GHZ;
+
+	freq = ieee80211_channel_to_frequency(pmlmeext->cur_channel, band);
+	chan = ieee80211_get_channel(wiphy, freq);
+
+	switch (pmlmeext->cur_bwmode) {
+	case CHANNEL_WIDTH_20:
+		chandef->width = NL80211_CHAN_WIDTH_20;
+		break;
+	case CHANNEL_WIDTH_40:
+		chandef->width = NL80211_CHAN_WIDTH_40;
+		break;
+	case CHANNEL_WIDTH_80:
+		chandef->width = NL80211_CHAN_WIDTH_80;
+		break;
+	case CHANNEL_WIDTH_80_80:
+		chandef->width = NL80211_CHAN_WIDTH_80P80;
+		break;
+	case CHANNEL_WIDTH_160:
+		chandef->width = NL80211_CHAN_WIDTH_160;
+		break;
+	default:
+		WARN_ON(1);
+		break;
+	}
+
+	center_ch = rtw_get_center_ch(pmlmeext->cur_channel, pmlmeext->cur_bwmode, pmlmeext->cur_ch_offset);
+	chandef->chan = chan;
+	chandef->center_freq1 = ieee80211_channel_to_frequency(center_ch, band);
+	chandef->center_freq2 = 0;
+
+	if (cfg80211_chandef_valid(chandef))
+		ret = 0;
+
+	#ifdef CONFIG_DEBUG_CFG80211
+	printk("%s: ret=%d, cur_channel=%d, cur_bwmode=%d, cur_ch_offset=%d, band=%d, center_ch=%d\n",
+		__func__, ret, pmlmeext->cur_channel, pmlmeext->cur_bwmode, pmlmeext->cur_ch_offset, band, center_ch);
+	#endif
+
+	return ret;
+}
+
 static struct cfg80211_ops rtw_cfg80211_ops = {
 	.change_virtual_intf = cfg80211_rtw_change_iface,
 	.add_key = cfg80211_rtw_add_key,
@@ -7411,6 +7469,7 @@ static struct cfg80211_ops rtw_cfg80211_
 #if defined(CONFIG_RTW_HOSTAPD_ACS) && (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 33))
 	.dump_survey = rtw_hostapd_acs_dump_survey,
 #endif
+	.get_channel = cfg80211_rtw_get_channel,
 };
 
 struct wiphy *rtw_wiphy_alloc(_adapter *padapter, struct device *dev)
Index: backports-2017-11-01/drivers/net/wireless/realtek/rtkwifiu/rtl8189es/os_dep/linux/ioctl_cfg80211.c
===================================================================
--- backports-2017-11-01.orig/drivers/net/wireless/realtek/rtkwifiu/rtl8189es/os_dep/linux/ioctl_cfg80211.c
+++ backports-2017-11-01/drivers/net/wireless/realtek/rtkwifiu/rtl8189es/os_dep/linux/ioctl_cfg80211.c
@@ -3940,7 +3940,7 @@ static int cfg80211_rtw_get_txpower(stru
 #endif
 	int *dbm)
 {
-	RTW_INFO("%s\n", __func__);
+	RTW_DBG("%s\n", __func__);
 
 	*dbm = (12);
 
@@ -5419,7 +5419,7 @@ static int	cfg80211_rtw_dump_station(str
 	u8 asoc_list_num;
 
 	if (DBG_DUMP_STATION)
-		RTW_INFO(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
+		RTW_DBG(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
 
 	_enter_critical_bh(&pstapriv->asoc_list_lock, &irqL);
 	psta = rtw_sta_info_get_by_idx(pstapriv, idx, &asoc_list_num);
@@ -5440,7 +5440,7 @@ static int	cfg80211_rtw_dump_station(str
 		#endif
 	) {
 		if (DBG_DUMP_STATION)
-			RTW_INFO(FUNC_NDEV_FMT" end with idx:%d\n", FUNC_NDEV_ARG(ndev), idx);
+			RTW_DBG(FUNC_NDEV_FMT" end with idx:%d\n", FUNC_NDEV_ARG(ndev), idx);
 		ret = -ENOENT;
 		goto exit;
 	}
@@ -9023,7 +9023,7 @@ static void rtw_cfg80211_preinit_wiphy(_
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 2, 0))
 	/* wiphy->flags |= WIPHY_FLAG_SUPPORTS_FW_ROAM; */
 #endif
-
+	_rtw_memcpy(wiphy->perm_addr, adapter_mac_addr(adapter), ETH_ALEN);
 #ifdef CONFIG_RTW_MESH
 	wiphy->flags |= 0
 		#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37))
@@ -9215,6 +9215,63 @@ int rtw_hostapd_acs_dump_survey(struct w
 }
 #endif /* defined(CONFIG_RTW_HOSTAPD_ACS) && (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 33)) */
 
+static int cfg80211_rtw_get_channel(struct wiphy *wiphy, struct wireless_dev *wdev, struct cfg80211_chan_def *chandef)
+{
+	_adapter *padapter = wiphy_to_adapter(wiphy);
+	struct dvobj_priv *dvobj = adapter_to_dvobj(padapter);
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
+	struct ieee80211_channel *chan;
+	enum nl80211_band band;
+	int ret = -ENODATA;
+	int freq;
+	u8 center_ch;
+
+	if (pmlmeext->cur_channel > 14)
+		band = NL80211_BAND_5GHZ;
+	else
+		band = NL80211_BAND_2GHZ;
+
+	freq = ieee80211_channel_to_frequency(pmlmeext->cur_channel, band);
+	chan = ieee80211_get_channel(wiphy, freq);
+
+	switch (pmlmeext->cur_bwmode) {
+	case CHANNEL_WIDTH_20:
+		chandef->width = NL80211_CHAN_WIDTH_20;
+		break;
+	case CHANNEL_WIDTH_40:
+		chandef->width = NL80211_CHAN_WIDTH_40;
+		break;
+	case CHANNEL_WIDTH_80:
+		chandef->width = NL80211_CHAN_WIDTH_80;
+		break;
+	case CHANNEL_WIDTH_80_80:
+		chandef->width = NL80211_CHAN_WIDTH_80P80;
+		break;
+	case CHANNEL_WIDTH_160:
+		chandef->width = NL80211_CHAN_WIDTH_160;
+		break;
+	default:
+		WARN_ON(1);
+		break;
+	}
+
+	center_ch = rtw_get_center_ch(pmlmeext->cur_channel, pmlmeext->cur_bwmode, pmlmeext->cur_ch_offset);
+	chandef->chan = chan;
+	chandef->center_freq1 = ieee80211_channel_to_frequency(center_ch, band);
+	chandef->center_freq2 = 0;
+
+	if (cfg80211_chandef_valid(chandef))
+		ret = 0;
+
+	#ifdef CONFIG_DEBUG_CFG80211
+	printk("%s: ret=%d, cur_channel=%d, cur_bwmode=%d, cur_ch_offset=%d, band=%d, center_ch=%d\n",
+		__func__, ret, pmlmeext->cur_channel, pmlmeext->cur_bwmode, pmlmeext->cur_ch_offset, band, center_ch);
+	#endif
+
+	return ret;
+}
+
 static struct cfg80211_ops rtw_cfg80211_ops = {
 	.change_virtual_intf = cfg80211_rtw_change_iface,
 	.add_key = cfg80211_rtw_add_key,
@@ -9329,6 +9386,7 @@ static struct cfg80211_ops rtw_cfg80211_
 #if defined(CONFIG_RTW_HOSTAPD_ACS) && (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 33))
 	.dump_survey = rtw_hostapd_acs_dump_survey,
 #endif
+	.get_channel = cfg80211_rtw_get_channel,
 };
 
 struct wiphy *rtw_wiphy_alloc(_adapter *padapter, struct device *dev)
Index: backports-2017-11-01/drivers/net/wireless/realtek/rtkwifiu/rtl8189fs/os_dep/linux/ioctl_cfg80211.c
===================================================================
--- backports-2017-11-01.orig/drivers/net/wireless/realtek/rtkwifiu/rtl8189fs/os_dep/linux/ioctl_cfg80211.c
+++ backports-2017-11-01/drivers/net/wireless/realtek/rtkwifiu/rtl8189fs/os_dep/linux/ioctl_cfg80211.c
@@ -3979,7 +3979,7 @@ static int cfg80211_rtw_get_txpower(stru
 #endif
 	int *dbm)
 {
-	RTW_INFO("%s\n", __func__);
+	RTW_DBG("%s\n", __func__);
 
 	*dbm = (12);
 
@@ -5469,7 +5469,7 @@ static int	cfg80211_rtw_dump_station(str
 	u8 asoc_list_num;
 
 	if (DBG_DUMP_STATION)
-		RTW_INFO(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
+		RTW_DBG(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
 
 	_enter_critical_bh(&pstapriv->asoc_list_lock, &irqL);
 	psta = rtw_sta_info_get_by_idx(pstapriv, idx, &asoc_list_num);
@@ -5490,7 +5490,7 @@ static int	cfg80211_rtw_dump_station(str
 		#endif
 	) {
 		if (DBG_DUMP_STATION)
-			RTW_INFO(FUNC_NDEV_FMT" end with idx:%d\n", FUNC_NDEV_ARG(ndev), idx);
+			RTW_DBG(FUNC_NDEV_FMT" end with idx:%d\n", FUNC_NDEV_ARG(ndev), idx);
 		ret = -ENOENT;
 		goto exit;
 	}
@@ -9103,7 +9103,7 @@ static void rtw_cfg80211_preinit_wiphy(_
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 2, 0))
 	/* wiphy->flags |= WIPHY_FLAG_SUPPORTS_FW_ROAM; */
 #endif
-
+	_rtw_memcpy(wiphy->perm_addr, adapter_mac_addr(adapter), ETH_ALEN);
 #ifdef CONFIG_RTW_MESH
 	wiphy->flags |= 0
 		#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37))
@@ -9295,6 +9295,63 @@ int rtw_hostapd_acs_dump_survey(struct w
 }
 #endif /* defined(CONFIG_RTW_HOSTAPD_ACS) && (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 33)) */
 
+static int cfg80211_rtw_get_channel(struct wiphy *wiphy, struct wireless_dev *wdev, struct cfg80211_chan_def *chandef)
+{
+	_adapter *padapter = wiphy_to_adapter(wiphy);
+	struct dvobj_priv *dvobj = adapter_to_dvobj(padapter);
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
+	struct ieee80211_channel *chan;
+	enum nl80211_band band;
+	int ret = -ENODATA;
+	int freq;
+	u8 center_ch;
+
+	if (pmlmeext->cur_channel > 14)
+		band = NL80211_BAND_5GHZ;
+	else
+		band = NL80211_BAND_2GHZ;
+
+	freq = ieee80211_channel_to_frequency(pmlmeext->cur_channel, band);
+	chan = ieee80211_get_channel(wiphy, freq);
+
+	switch (pmlmeext->cur_bwmode) {
+	case CHANNEL_WIDTH_20:
+		chandef->width = NL80211_CHAN_WIDTH_20;
+		break;
+	case CHANNEL_WIDTH_40:
+		chandef->width = NL80211_CHAN_WIDTH_40;
+		break;
+	case CHANNEL_WIDTH_80:
+		chandef->width = NL80211_CHAN_WIDTH_80;
+		break;
+	case CHANNEL_WIDTH_80_80:
+		chandef->width = NL80211_CHAN_WIDTH_80P80;
+		break;
+	case CHANNEL_WIDTH_160:
+		chandef->width = NL80211_CHAN_WIDTH_160;
+		break;
+	default:
+		WARN_ON(1);
+		break;
+	}
+
+	center_ch = rtw_get_center_ch(pmlmeext->cur_channel, pmlmeext->cur_bwmode, pmlmeext->cur_ch_offset);
+	chandef->chan = chan;
+	chandef->center_freq1 = ieee80211_channel_to_frequency(center_ch, band);
+	chandef->center_freq2 = 0;
+
+	if (cfg80211_chandef_valid(chandef))
+		ret = 0;
+
+	#ifdef CONFIG_DEBUG_CFG80211
+	printk("%s: ret=%d, cur_channel=%d, cur_bwmode=%d, cur_ch_offset=%d, band=%d, center_ch=%d\n",
+		__func__, ret, pmlmeext->cur_channel, pmlmeext->cur_bwmode, pmlmeext->cur_ch_offset, band, center_ch);
+	#endif
+
+	return ret;
+}
+
 static struct cfg80211_ops rtw_cfg80211_ops = {
 	.change_virtual_intf = cfg80211_rtw_change_iface,
 	.add_key = cfg80211_rtw_add_key,
@@ -9410,6 +9467,7 @@ static struct cfg80211_ops rtw_cfg80211_
 #if defined(CONFIG_RTW_HOSTAPD_ACS) && (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 33))
 	.dump_survey = rtw_hostapd_acs_dump_survey,
 #endif
+	.get_channel = cfg80211_rtw_get_channel,
 };
 
 struct wiphy *rtw_wiphy_alloc(_adapter *padapter, struct device *dev)
Index: backports-2017-11-01/drivers/net/wireless/realtek/rtkwifiu/rtl8723bu/os_dep/linux/ioctl_cfg80211.c
===================================================================
--- backports-2017-11-01.orig/drivers/net/wireless/realtek/rtkwifiu/rtl8723bu/os_dep/linux/ioctl_cfg80211.c
+++ backports-2017-11-01/drivers/net/wireless/realtek/rtkwifiu/rtl8723bu/os_dep/linux/ioctl_cfg80211.c
@@ -3517,7 +3517,7 @@ static int cfg80211_rtw_get_txpower(stru
 #endif
 	int *dbm)
 {
-	DBG_8192C("%s\n", __func__);
+	/* DBG_8192C("%s\n", __func__); */
 
 	*dbm = (12);
 	
@@ -4535,14 +4535,14 @@ static int	cfg80211_rtw_dump_station(str
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(ndev);
 	struct sta_info *psta = NULL;
 	struct sta_priv *pstapriv = &padapter->stapriv;
-	DBG_871X(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
+	/* DBG_871X(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev)); */
 
 	_enter_critical_bh(&pstapriv->asoc_list_lock, &irqL);
 	psta = rtw_sta_info_get_by_idx(idx, pstapriv);
 	_exit_critical_bh(&pstapriv->asoc_list_lock, &irqL);
 	if(NULL == psta)
 	{
-		DBG_871X("Station is not found\n");
+		/* DBG_871X("Station is not found\n"); */
 		ret = -ENOENT;
 		goto exit;
 	}
@@ -5821,6 +5821,174 @@ static int cfg80211_rtw_sched_scan_stop(
 }
 #endif /* CONFIG_PNO_SUPPORT */
 
+#ifdef CONFIG_FIND_BEST_CHANNEL
+static int get_best_channel(_adapter *padapter, enum nl80211_band band)
+{
+	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
+	u32 i, best_channel_24G = 1, best_channel_5G = 36, index_24G = 0, index_5G = 0;
+
+	for (i=0; pmlmeext->channel_set[i].ChannelNum !=0; i++) {
+		if ( pmlmeext->channel_set[i].ChannelNum == 1)
+			index_24G = i;
+		if ( pmlmeext->channel_set[i].ChannelNum == 36)
+			index_5G = i;
+	}
+
+	for (i=0; (i < MAX_CHANNEL_NUM) && (pmlmeext->channel_set[i].ChannelNum !=0) ; i++) {
+		if (pmlmeext->channel_set[i].ScanType == SCAN_PASSIVE)
+			continue;
+		// 2.4G
+		if ( pmlmeext->channel_set[i].ChannelNum == 6 || pmlmeext->channel_set[i].ChannelNum == 11) {
+			if ( pmlmeext->channel_set[i].rx_count < pmlmeext->channel_set[index_24G].rx_count ) {
+				index_24G = i;
+				best_channel_24G = pmlmeext->channel_set[i].ChannelNum;
+			}
+		}
+
+		// 5G
+		if ( pmlmeext->channel_set[i].ChannelNum >= 36
+			&& pmlmeext->channel_set[i].ChannelNum < 140 ) {
+			// Find primary channel
+			if ( (( pmlmeext->channel_set[i].ChannelNum - 36) % 8 == 0)
+				&& (pmlmeext->channel_set[i].rx_count < pmlmeext->channel_set[index_5G].rx_count) ) {
+				index_5G = i;
+				best_channel_5G = pmlmeext->channel_set[i].ChannelNum;
+			}
+		}
+
+		if ( pmlmeext->channel_set[i].ChannelNum >= 149
+			&& pmlmeext->channel_set[i].ChannelNum < 165) {
+			// find primary channel
+			if ( (( pmlmeext->channel_set[i].ChannelNum - 149) % 8 == 0)
+				&& (pmlmeext->channel_set[i].rx_count < pmlmeext->channel_set[index_5G].rx_count) ) {
+				index_5G = i;
+				best_channel_5G = pmlmeext->channel_set[i].ChannelNum;
+			}
+		}
+	}
+
+	if (band == NL80211_BAND_2GHZ)
+		return best_channel_24G;
+
+	return best_channel_5G;
+}
+#endif
+
+static int cfg80211_rtw_dump_survey(struct wiphy *wiphy, struct net_device *dev, int idx, struct survey_info *survey)
+{
+	_adapter *padapter = wiphy_to_adapter(wiphy);
+	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
+	struct ss_res *ss = &pmlmeext->sitesurvey_res;
+	struct rtw_ieee80211_channel *ch;
+	struct ieee80211_supported_band *sband=NULL;
+	int freq, band=0;
+	int best_ch = -1;
+
+	if (idx >= ss->ch_num)
+		return -EINVAL;
+
+	ch = &ss->ch[idx];
+
+	if (!ch)
+		return -EINVAL;
+
+	if (ch->hw_value > 14)
+		band = NL80211_BAND_5GHZ;
+	else
+		band = NL80211_BAND_2GHZ;
+
+	sband = wiphy->bands[band];
+
+	if(!sband) {
+		printk("%s under unknown band!!\n",dev->name);
+		return -EINVAL;
+	}
+
+	if(sband->band == NL80211_BAND_2GHZ)
+		freq = ieee80211_channel_to_frequency(ch->hw_value, NL80211_BAND_2GHZ);
+	else
+		freq = ieee80211_channel_to_frequency(ch->hw_value, NL80211_BAND_5GHZ);
+
+	survey->channel = ieee80211_get_channel(wiphy, freq);
+	#ifdef CONFIG_FIND_BEST_CHANNEL
+	best_ch = get_best_channel(padapter, sband->band);
+	#endif
+
+	if (best_ch == ch->hw_value)
+		survey->noise = -100;
+	else
+		survey->noise = -50;
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4,0,0))
+	survey->time = 100;
+	survey->time_busy = 50;
+	survey->filled = SURVEY_INFO_NOISE_DBM | SURVEY_INFO_TIME | SURVEY_INFO_TIME_BUSY;
+#else
+	survey->channel_time = 100;
+	survey->channel_time_busy = 50
+	survey->filled = SURVEY_INFO_NOISE_DBM | SURVEY_INFO_CHANNEL_TIME | SURVEY_INFO_CHANNEL_TIME_BUSY;
+#endif
+
+	return 0;
+}
+
+static int cfg80211_rtw_get_channel(struct wiphy *wiphy, struct wireless_dev *wdev, struct cfg80211_chan_def *chandef)
+{
+	_adapter *padapter = wiphy_to_adapter(wiphy);
+	struct dvobj_priv *dvobj = adapter_to_dvobj(padapter);
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
+	struct ieee80211_channel *chan;
+	enum nl80211_band band;
+	int ret = -ENODATA;
+	int freq;
+	u8 center_ch;
+
+	if (pmlmeext->cur_channel > 14)
+		band = NL80211_BAND_5GHZ;
+	else
+		band = NL80211_BAND_2GHZ;
+
+	freq = ieee80211_channel_to_frequency(pmlmeext->cur_channel, band);
+	chan = ieee80211_get_channel(wiphy, freq);
+
+	switch (pmlmeext->cur_bwmode) {
+	case CHANNEL_WIDTH_20:
+		chandef->width = NL80211_CHAN_WIDTH_20;
+		break;
+	case CHANNEL_WIDTH_40:
+		chandef->width = NL80211_CHAN_WIDTH_40;
+		break;
+	case CHANNEL_WIDTH_80:
+		chandef->width = NL80211_CHAN_WIDTH_80;
+		break;
+	case CHANNEL_WIDTH_80_80:
+		chandef->width = NL80211_CHAN_WIDTH_80P80;
+		break;
+	case CHANNEL_WIDTH_160:
+		chandef->width = NL80211_CHAN_WIDTH_160;
+		break;
+	default:
+		WARN_ON(1);
+		break;
+	}
+
+	center_ch = rtw_get_center_ch(pmlmeext->cur_channel, pmlmeext->cur_bwmode, pmlmeext->cur_ch_offset);
+	chandef->chan = chan;
+	chandef->center_freq1 = ieee80211_channel_to_frequency(center_ch, band);
+	chandef->center_freq2 = 0;
+
+	if (cfg80211_chandef_valid(chandef))
+		ret = 0;
+
+	#ifdef CONFIG_DEBUG_CFG80211
+	printk("%s: ret=%d, cur_channel=%d, cur_bwmode=%d, cur_ch_offset=%d, band=%d, center_ch=%d\n",
+		__func__, ret, pmlmeext->cur_channel, pmlmeext->cur_bwmode, pmlmeext->cur_ch_offset, band, center_ch);
+	#endif
+
+	return ret;
+}
+
 static int rtw_cfg80211_set_beacon_wpsp2pie(struct net_device *ndev, char *buf, int len)
 {	
 	int ret = 0;
@@ -6406,7 +6574,7 @@ static void rtw_cfg80211_preinit_wiphy(_
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,2,0))
 	//wiphy->flags |= WIPHY_FLAG_SUPPORTS_FW_ROAM;
 #endif
-
+	_rtw_memcpy(wiphy->perm_addr, adapter_mac_addr(padapter), ETH_ALEN);
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)) || defined(RTW_VENDOR_EXT_SUPPORT)
 	rtw_cfgvendor_attach(wiphy);
 #endif
@@ -6484,6 +6652,8 @@ static struct cfg80211_ops rtw_cfg80211_
 	.sched_scan_start = cfg80211_rtw_sched_scan_start,
 	.sched_scan_stop = cfg80211_rtw_sched_scan_stop,
 #endif /* CONFIG_PNO_SUPPORT */
+	.dump_survey = cfg80211_rtw_dump_survey,
+	.get_channel = cfg80211_rtw_get_channel,
 };
 
 int rtw_wdev_alloc(_adapter *padapter, struct device *dev)
